Imports System
Imports System.Collections.Generic
Imports System.Runtime.InteropServices

'
' * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
' * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' 

Namespace java.lang.reflect


	''' <summary>
	''' {@code Proxy} provides static methods for creating dynamic proxy
	''' classes and instances, and it is also the superclass of all
	''' dynamic proxy classes created by those methods.
	''' 
	''' <p>To create a proxy for some interface {@code Foo}:
	''' <pre>
	'''     InvocationHandler handler = new MyInvocationHandler(...);
	'''     Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);
	'''     Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).
	'''                     newInstance(handler);
	''' </pre>
	''' or more simply:
	''' <pre>
	'''     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
	'''                                          new Class&lt;?&gt;[] { Foo.class },
	'''                                          handler);
	''' </pre>
	''' 
	''' <p>A <i>dynamic proxy class</i> (simply referred to as a <i>proxy
	''' class</i> below) is a class that implements a list of interfaces
	''' specified at runtime when the class is created, with behavior as
	''' described below.
	''' 
	''' A <i>proxy interface</i> is such an interface that is implemented
	''' by a proxy class.
	''' 
	''' A <i>proxy instance</i> is an instance of a proxy class.
	''' 
	''' Each proxy instance has an associated <i>invocation handler</i>
	''' object, which implements the interface <seealso cref="InvocationHandler"/>.
	''' A method invocation on a proxy instance through one of its proxy
	''' interfaces will be dispatched to the {@link InvocationHandler#invoke
	''' invoke} method of the instance's invocation handler, passing the proxy
	''' instance, a {@code java.lang.reflect.Method} object identifying
	''' the method that was invoked, and an array of type {@code Object}
	''' containing the arguments.  The invocation handler processes the
	''' encoded method invocation as appropriate and the result that it
	''' returns will be returned as the result of the method invocation on
	''' the proxy instance.
	''' 
	''' <p>A proxy class has the following properties:
	''' 
	''' <ul>
	''' <li>Proxy classes are <em>public, final, and not abstract</em> if
	''' all proxy interfaces are public.</li>
	''' 
	''' <li>Proxy classes are <em>non-public, final, and not abstract</em> if
	''' any of the proxy interfaces is non-public.</li>
	''' 
	''' <li>The unqualified name of a proxy class is unspecified.  The space
	''' of class names that begin with the string {@code "$Proxy"}
	''' should be, however, reserved for proxy classes.
	''' 
	''' <li>A proxy class extends {@code java.lang.reflect.Proxy}.
	''' 
	''' <li>A proxy class implements exactly the interfaces specified at its
	''' creation, in the same order.
	''' 
	''' <li>If a proxy class implements a non-public interface, then it will
	''' be defined in the same package as that interface.  Otherwise, the
	''' package of a proxy class is also unspecified.  Note that package
	''' sealing will not prevent a proxy class from being successfully defined
	''' in a particular package at runtime, and neither will classes already
	''' defined by the same class loader and the same package with particular
	''' signers.
	''' 
	''' <li>Since a proxy class implements all of the interfaces specified at
	''' its creation, invoking {@code getInterfaces} on its
	''' {@code Class} object will return an array containing the same
	''' list of interfaces (in the order specified at its creation), invoking
	''' {@code getMethods} on its {@code Class} object will return
	''' an array of {@code Method} objects that include all of the
	''' methods in those interfaces, and invoking {@code getMethod} will
	''' find methods in the proxy interfaces as would be expected.
	''' 
	''' <li>The <seealso cref="Proxy#isProxyClass Proxy.isProxyClass"/> method will
	''' return true if it is passed a proxy class-- a class returned by
	''' {@code Proxy.getProxyClass} or the class of an object returned by
	''' {@code Proxy.newProxyInstance}-- and false otherwise.
	''' 
	''' <li>The {@code java.security.ProtectionDomain} of a proxy class
	''' is the same as that of system classes loaded by the bootstrap class
	''' loader, such as {@code java.lang.Object}, because the code for a
	''' proxy class is generated by trusted system code.  This protection
	''' domain will typically be granted
	''' {@code java.security.AllPermission}.
	''' 
	''' <li>Each proxy class has one public constructor that takes one argument,
	''' an implementation of the interface <seealso cref="InvocationHandler"/>, to set
	''' the invocation handler for a proxy instance.  Rather than having to use
	''' the reflection API to access the public constructor, a proxy instance
	''' can be also be created by calling the {@link Proxy#newProxyInstance
	''' Proxy.newProxyInstance} method, which combines the actions of calling
	''' <seealso cref="Proxy#getProxyClass Proxy.getProxyClass"/> with invoking the
	''' constructor with an invocation handler.
	''' </ul>
	''' 
	''' <p>A proxy instance has the following properties:
	''' 
	''' <ul>
	''' <li>Given a proxy instance {@code proxy} and one of the
	''' interfaces implemented by its proxy class {@code Foo}, the
	''' following expression will return true:
	''' <pre>
	'''     {@code proxy instanceof Foo}
	''' </pre>
	''' and the following cast operation will succeed (rather than throwing
	''' a {@code ClassCastException}):
	''' <pre>
	'''     {@code (Foo) proxy}
	''' </pre>
	''' 
	''' <li>Each proxy instance has an associated invocation handler, the one
	''' that was passed to its constructor.  The static
	''' <seealso cref="Proxy#getInvocationHandler Proxy.getInvocationHandler"/> method
	''' will return the invocation handler associated with the proxy instance
	''' passed as its argument.
	''' 
	''' <li>An interface method invocation on a proxy instance will be
	''' encoded and dispatched to the invocation handler's {@link
	''' InvocationHandler#invoke invoke} method as described in the
	''' documentation for that method.
	''' 
	''' <li>An invocation of the {@code hashCode},
	''' {@code equals}, or {@code toString} methods declared in
	''' {@code java.lang.Object} on a proxy instance will be encoded and
	''' dispatched to the invocation handler's {@code invoke} method in
	''' the same manner as interface method invocations are encoded and
	''' dispatched, as described above.  The declaring class of the
	''' {@code Method} object passed to {@code invoke} will be
	''' {@code java.lang.Object}.  Other public methods of a proxy
	''' instance inherited from {@code java.lang.Object} are not
	''' overridden by a proxy class, so invocations of those methods behave
	''' like they do for instances of {@code java.lang.Object}.
	''' </ul>
	''' 
	''' <h3>Methods Duplicated in Multiple Proxy Interfaces</h3>
	''' 
	''' <p>When two or more interfaces of a proxy class contain a method with
	''' the same name and parameter signature, the order of the proxy class's
	''' interfaces becomes significant.  When such a <i>duplicate method</i>
	''' is invoked on a proxy instance, the {@code Method} object passed
	''' to the invocation handler will not necessarily be the one whose
	''' declaring class is assignable from the reference type of the interface
	''' that the proxy's method was invoked through.  This limitation exists
	''' because the corresponding method implementation in the generated proxy
	''' class cannot determine which interface it was invoked through.
	''' Therefore, when a duplicate method is invoked on a proxy instance,
	''' the {@code Method} object for the method in the foremost interface
	''' that contains the method (either directly or inherited through a
	''' superinterface) in the proxy class's list of interfaces is passed to
	''' the invocation handler's {@code invoke} method, regardless of the
	''' reference type through which the method invocation occurred.
	''' 
	''' <p>If a proxy interface contains a method with the same name and
	''' parameter signature as the {@code hashCode}, {@code equals},
	''' or {@code toString} methods of {@code java.lang.Object},
	''' when such a method is invoked on a proxy instance, the
	''' {@code Method} object passed to the invocation handler will have
	''' {@code java.lang.Object} as its declaring class.  In other words,
	''' the public, non-final methods of {@code java.lang.Object}
	''' logically precede all of the proxy interfaces for the determination of
	''' which {@code Method} object to pass to the invocation handler.
	''' 
	''' <p>Note also that when a duplicate method is dispatched to an
	''' invocation handler, the {@code invoke} method may only throw
	''' checked exception types that are assignable to one of the exception
	''' types in the {@code throws} clause of the method in <i>all</i> of
	''' the proxy interfaces that it can be invoked through.  If the
	''' {@code invoke} method throws a checked exception that is not
	''' assignable to any of the exception types declared by the method in one
	''' of the proxy interfaces that it can be invoked through, then an
	''' unchecked {@code UndeclaredThrowableException} will be thrown by
	''' the invocation on the proxy instance.  This restriction means that not
	''' all of the exception types returned by invoking
	''' {@code getExceptionTypes} on the {@code Method} object
	''' passed to the {@code invoke} method can necessarily be thrown
	''' successfully by the {@code invoke} method.
	''' 
	''' @author      Peter Jones </summary>
	''' <seealso cref=         InvocationHandler
	''' @since       1.3 </seealso>
	<Serializable> _
	Public Class Proxy

		Private Const serialVersionUID As Long = -2222568056686623797L

		''' <summary>
		''' parameter types of a proxy class constructor </summary>
		Private Shared ReadOnly constructorParams As Class() = { GetType(InvocationHandler) }

		''' <summary>
		''' a cache of proxy classes
		''' </summary>
		Private Shared ReadOnly proxyClassCache As New WeakCache(Of ClassLoader, Class(), Class)(New KeyFactory, New ProxyClassFactory)

		''' <summary>
		''' the invocation handler for this proxy instance.
		''' @serial
		''' </summary>
		Protected Friend h As InvocationHandler

		''' <summary>
		''' Prohibits instantiation.
		''' </summary>
		Private Sub New()
		End Sub

		''' <summary>
		''' Constructs a new {@code Proxy} instance from a subclass
		''' (typically, a dynamic proxy class) with the specified value
		''' for its invocation handler.
		''' </summary>
		''' <param name="h"> the invocation handler for this proxy instance
		''' </param>
		''' <exception cref="NullPointerException"> if the given invocation handler, {@code h},
		'''         is {@code null}. </exception>
		Protected Friend Sub New(ByVal h As InvocationHandler)
			java.util.Objects.requireNonNull(h)
			Me.h = h
		End Sub

		''' <summary>
		''' Returns the {@code java.lang.Class} object for a proxy class
		''' given a class loader and an array of interfaces.  The proxy class
		''' will be defined by the specified class loader and will implement
		''' all of the supplied interfaces.  If any of the given interfaces
		''' is non-public, the proxy class will be non-public. If a proxy class
		''' for the same permutation of interfaces has already been defined by the
		''' class loader, then the existing proxy class will be returned; otherwise,
		''' a proxy class for those interfaces will be generated dynamically
		''' and defined by the class loader.
		''' 
		''' <p>There are several restrictions on the parameters that may be
		''' passed to {@code Proxy.getProxyClass}:
		''' 
		''' <ul>
		''' <li>All of the {@code Class} objects in the
		''' {@code interfaces} array must represent interfaces, not
		''' classes or primitive types.
		''' 
		''' <li>No two elements in the {@code interfaces} array may
		''' refer to identical {@code Class} objects.
		''' 
		''' <li>All of the interface types must be visible by name through the
		''' specified class loader.  In other words, for class loader
		''' {@code cl} and every interface {@code i}, the following
		''' expression must be true:
		''' <pre>
		'''     Class.forName(i.getName(), false, cl) == i
		''' </pre>
		''' 
		''' <li>All non-public interfaces must be in the same package;
		''' otherwise, it would not be possible for the proxy class to
		''' implement all of the interfaces, regardless of what package it is
		''' defined in.
		''' 
		''' <li>For any set of member methods of the specified interfaces
		''' that have the same signature:
		''' <ul>
		''' <li>If the return type of any of the methods is a primitive
		''' type or void, then all of the methods must have that same
		''' return type.
		''' <li>Otherwise, one of the methods must have a return type that
		''' is assignable to all of the return types of the rest of the
		''' methods.
		''' </ul>
		''' 
		''' <li>The resulting proxy class must not exceed any limits imposed
		''' on classes by the virtual machine.  For example, the VM may limit
		''' the number of interfaces that a class may implement to 65535; in
		''' that case, the size of the {@code interfaces} array must not
		''' exceed 65535.
		''' </ul>
		''' 
		''' <p>If any of these restrictions are violated,
		''' {@code Proxy.getProxyClass} will throw an
		''' {@code IllegalArgumentException}.  If the {@code interfaces}
		''' array argument or any of its elements are {@code null}, a
		''' {@code NullPointerException} will be thrown.
		''' 
		''' <p>Note that the order of the specified proxy interfaces is
		''' significant: two requests for a proxy class with the same combination
		''' of interfaces but in a different order will result in two distinct
		''' proxy classes.
		''' </summary>
		''' <param name="loader"> the class loader to define the proxy class </param>
		''' <param name="interfaces"> the list of interfaces for the proxy class
		'''          to implement </param>
		''' <returns>  a proxy class that is defined in the specified class loader
		'''          and that implements the specified interfaces </returns>
		''' <exception cref="IllegalArgumentException"> if any of the restrictions on the
		'''          parameters that may be passed to {@code getProxyClass}
		'''          are violated </exception>
		''' <exception cref="SecurityException"> if a security manager, <em>s</em>, is present
		'''          and any of the following conditions is met:
		'''          <ul>
		'''             <li> the given {@code loader} is {@code null} and
		'''             the caller's class loader is not {@code null} and the
		'''             invocation of {@link SecurityManager#checkPermission
		'''             s.checkPermission} with
		'''             {@code RuntimePermission("getClassLoader")} permission
		'''             denies access.</li>
		'''             <li> for each proxy interface, {@code intf},
		'''             the caller's class loader is not the same as or an
		'''             ancestor of the class loader for {@code intf} and
		'''             invocation of {@link SecurityManager#checkPackageAccess
		'''             s.checkPackageAccess()} denies access to {@code intf}.</li>
		'''          </ul>
		''' </exception>
		''' <exception cref="NullPointerException"> if the {@code interfaces} array
		'''          argument or any of its elements are {@code null} </exception>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
		Public Shared Function getProxyClass(ByVal loader As ClassLoader, ParamArray ByVal interfaces As Class()) As Class
			Dim intfs As Class() = interfaces.clone()
			Dim sm As SecurityManager = System.securityManager
			If sm IsNot Nothing Then checkProxyAccess(sun.reflect.Reflection.callerClass, loader, intfs)

			Return getProxyClass0(loader, intfs)
		End Function

	'    
	'     * Check permissions required to create a Proxy class.
	'     *
	'     * To define a proxy class, it performs the access checks as in
	'     * Class.forName (VM will invoke ClassLoader.checkPackageAccess):
	'     * 1. "getClassLoader" permission check if loader == null
	'     * 2. checkPackageAccess on the interfaces it implements
	'     *
	'     * To get a constructor and new instance of a proxy class, it performs
	'     * the package access check on the interfaces it implements
	'     * as in Class.getConstructor.
	'     *
	'     * If an interface is non-public, the proxy class must be defined by
	'     * the defining loader of the interface.  If the caller's class loader
	'     * is not the same as the defining loader of the interface, the VM
	'     * will throw IllegalAccessError when the generated proxy class is
	'     * being defined via the defineClass0 method.
	'     
		Private Shared Sub checkProxyAccess(ByVal caller As Class, ByVal loader As ClassLoader, ParamArray ByVal interfaces As Class())
			Dim sm As SecurityManager = System.securityManager
			If sm IsNot Nothing Then
				Dim ccl As ClassLoader = caller.classLoader
				If sun.misc.VM.isSystemDomainLoader(loader) AndAlso (Not sun.misc.VM.isSystemDomainLoader(ccl)) Then sm.checkPermission(sun.security.util.SecurityConstants.GET_CLASSLOADER_PERMISSION)
				sun.reflect.misc.ReflectUtil.checkProxyPackageAccess(ccl, interfaces)
			End If
		End Sub

		''' <summary>
		''' Generate a proxy class.  Must call the checkProxyAccess method
		''' to perform permission checks before calling this.
		''' </summary>
		Private Shared Function getProxyClass0(ByVal loader As ClassLoader, ParamArray ByVal interfaces As Class()) As Class
			If interfaces.Length > 65535 Then Throw New IllegalArgumentException("interface limit exceeded")

			' If the proxy class defined by the given loader implementing
			' the given interfaces exists, this will simply return the cached copy;
			' otherwise, it will create the proxy class via the ProxyClassFactory
			Return proxyClassCache.get(loader, interfaces)
		End Function

	'    
	'     * a key used for proxy class with 0 implemented interfaces
	'     
		Private Shared ReadOnly key0 As New Object

	'    
	'     * Key1 and Key2 are optimized for the common use of dynamic proxies
	'     * that implement 1 or 2 interfaces.
	'     

	'    
	'     * a key used for proxy class with 1 implemented interface
	'     
		Private NotInheritable Class Key1
			Inherits WeakReference(Of [Class])

			Private ReadOnly hash As Integer

			Friend Sub New(ByVal intf As Class)
				MyBase.New(intf)
				Me.hash = intf.GetHashCode()
			End Sub

			Public Overrides Function GetHashCode() As Integer
				Return hash
			End Function

			Public Overrides Function Equals(ByVal obj As Object) As Boolean
				Dim intf As Class
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
				Return Me Is obj OrElse obj IsNot Nothing AndAlso obj.GetType() Is GetType(Key1) AndAlso (intf = get()) IsNot Nothing AndAlso intf Is CType(obj, Key1).get()
			End Function
		End Class

	'    
	'     * a key used for proxy class with 2 implemented interfaces
	'     
		Private NotInheritable Class Key2
			Inherits WeakReference(Of [Class])

			Private ReadOnly hash As Integer
			Private ReadOnly ref2 As WeakReference(Of [Class])

			Friend Sub New(ByVal intf1 As Class, ByVal intf2 As Class)
				MyBase.New(intf1)
				hash = 31 * intf1.GetHashCode() + intf2.GetHashCode()
				ref2 = New WeakReference(Of [Class])(intf2)
			End Sub

			Public Overrides Function GetHashCode() As Integer
				Return hash
			End Function

			Public Overrides Function Equals(ByVal obj As Object) As Boolean
				Dim intf1, intf2 As Class
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
				Return Me Is obj OrElse obj IsNot Nothing AndAlso obj.GetType() Is GetType(Key2) AndAlso (intf1 = get()) IsNot Nothing AndAlso intf1 Is CType(obj, Key2).get() AndAlso (intf2 = ref2.get()) IsNot Nothing AndAlso intf2 Is CType(obj, Key2).ref2.get()
			End Function
		End Class

	'    
	'     * a key used for proxy class with any number of implemented interfaces
	'     * (used here for 3 or more only)
	'     
		Private NotInheritable Class KeyX
			Private ReadOnly hash As Integer
			Private ReadOnly refs As WeakReference(Of [Class])()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
			Friend Sub New(ByVal interfaces As Class())
				hash = java.util.Arrays.hashCode(interfaces)
'JAVA TO VB CONVERTER TODO TASK: Java wildcard generics are not converted to .NET:
				refs = CType(New WeakReference(Of ?)(interfaces.Length - 1){}, WeakReference(Of [Class])())
				For i As Integer = 0 To interfaces.Length - 1
					refs(i) = New WeakReference(Of )(interfaces(i))
				Next i
			End Sub

			Public Overrides Function GetHashCode() As Integer
				Return hash
			End Function

			Public Overrides Function Equals(ByVal obj As Object) As Boolean
				Return Me Is obj OrElse obj IsNot Nothing AndAlso obj.GetType() Is GetType(KeyX) AndAlso Equals(refs, CType(obj, KeyX).refs)
			End Function

			Private Shared Function Equals(ByVal refs1 As WeakReference(Of [Class])(), ByVal refs2 As WeakReference(Of [Class])()) As Boolean
				If refs1.Length <> refs2.Length Then Return False
				For i As Integer = 0 To refs1.Length - 1
					Dim intf As Class = refs1(i).get()
					If intf Is Nothing OrElse intf IsNot refs2(i).get() Then Return False
				Next i
				Return True
			End Function
		End Class

		''' <summary>
		''' A function that maps an array of interfaces to an optimal key where
		''' Class objects representing interfaces are weakly referenced.
		''' </summary>
		Private NotInheritable Class KeyFactory
			Implements java.util.function.BiFunction(Of ClassLoader, Class(), Object)

			Public Overrides Function apply(ByVal classLoader_Renamed As ClassLoader, ByVal interfaces As Class()) As Object
				Select Case interfaces.Length
					Case 1 ' the most frequent
						Return New Key1(interfaces(0))
					Case 2
						Return New Key2(interfaces(0), interfaces(1))
					Case 0
						Return key0
					Case Else
						Return New KeyX(interfaces)
				End Select
			End Function
		End Class

		''' <summary>
		''' A factory function that generates, defines and returns the proxy class given
		''' the ClassLoader and array of interfaces.
		''' </summary>
		Private NotInheritable Class ProxyClassFactory
			Implements java.util.function.BiFunction(Of ClassLoader, Class(), Class)

			' prefix for all proxy class names
			Private Const proxyClassNamePrefix As String = "$Proxy"

			' next number to use for generation of unique proxy class names
			Private Shared ReadOnly nextUniqueNumber As New java.util.concurrent.atomic.AtomicLong

			Public Overrides Function apply(ByVal loader As ClassLoader, ByVal interfaces As Class()) As Class

				Dim interfaceSet As IDictionary(Of [Class], Boolean?) = New java.util.IdentityHashMap(Of [Class], Boolean?)(interfaces.Length)
				For Each intf As Class In interfaces
	'                
	'                 * Verify that the class loader resolves the name of this
	'                 * interface to the same Class object.
	'                 
					Dim interfaceClass As Class = Nothing
					Try
						interfaceClass = Type.GetType(intf.name, False, loader)
					Catch e As ClassNotFoundException
					End Try
					If interfaceClass IsNot intf Then Throw New IllegalArgumentException(intf & " is not visible from class loader")
	'                
	'                 * Verify that the Class object actually represents an
	'                 * interface.
	'                 
					If Not interfaceClass.interface Then Throw New IllegalArgumentException(interfaceClass.name & " is not an interface")
	'                
	'                 * Verify that this interface is not a duplicate.
	'                 
					If interfaceSet.put(interfaceClass, Boolean.TRUE) IsNot Nothing Then Throw New IllegalArgumentException("repeated interface: " & interfaceClass.name)
				Next intf

				Dim proxyPkg As String = Nothing ' package to define proxy class in
				Dim accessFlags As Integer = Modifier.PUBLIC Or Modifier.FINAL

	'            
	'             * Record the package of a non-public proxy interface so that the
	'             * proxy class will be defined in the same package.  Verify that
	'             * all non-public proxy interfaces are in the same package.
	'             
				For Each intf As Class In interfaces
					Dim flags As Integer = intf.modifiers
					If Not Modifier.isPublic(flags) Then
						accessFlags = Modifier.FINAL
						Dim name As String = intf.name
						Dim n As Integer = name.LastIndexOf("."c)
						Dim pkg As String = (If(n = -1, "", name.Substring(0, n + 1)))
						If proxyPkg Is Nothing Then
							proxyPkg = pkg
						ElseIf Not pkg.Equals(proxyPkg) Then
							Throw New IllegalArgumentException("non-public interfaces from different packages")
						End If
					End If
				Next intf

				If proxyPkg Is Nothing Then proxyPkg = sun.reflect.misc.ReflectUtil.PROXY_PACKAGE & "."

	'            
	'             * Choose a name for the proxy class to generate.
	'             
				Dim num As Long = nextUniqueNumber.andIncrement
				Dim proxyName As String = proxyPkg + proxyClassNamePrefix + num

	'            
	'             * Generate the specified proxy class.
	'             
				Dim proxyClassFile As SByte() = sun.misc.ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)
				Try
					Return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.Length)
				Catch e As ClassFormatError
	'                
	'                 * A ClassFormatError here means that (barring bugs in the
	'                 * proxy class generation code) there was some other
	'                 * invalid aspect of the arguments supplied to the proxy
	'                 * class creation (such as virtual machine limitations
	'                 * exceeded).
	'                 
					Throw New IllegalArgumentException(e.ToString())
				End Try
			End Function
		End Class

		''' <summary>
		''' Returns an instance of a proxy class for the specified interfaces
		''' that dispatches method invocations to the specified invocation
		''' handler.
		''' 
		''' <p>{@code Proxy.newProxyInstance} throws
		''' {@code IllegalArgumentException} for the same reasons that
		''' {@code Proxy.getProxyClass} does.
		''' </summary>
		''' <param name="loader"> the class loader to define the proxy class </param>
		''' <param name="interfaces"> the list of interfaces for the proxy class
		'''          to implement </param>
		''' <param name="h"> the invocation handler to dispatch method invocations to </param>
		''' <returns>  a proxy instance with the specified invocation handler of a
		'''          proxy class that is defined by the specified class loader
		'''          and that implements the specified interfaces </returns>
		''' <exception cref="IllegalArgumentException"> if any of the restrictions on the
		'''          parameters that may be passed to {@code getProxyClass}
		'''          are violated </exception>
		''' <exception cref="SecurityException"> if a security manager, <em>s</em>, is present
		'''          and any of the following conditions is met:
		'''          <ul>
		'''          <li> the given {@code loader} is {@code null} and
		'''               the caller's class loader is not {@code null} and the
		'''               invocation of {@link SecurityManager#checkPermission
		'''               s.checkPermission} with
		'''               {@code RuntimePermission("getClassLoader")} permission
		'''               denies access;</li>
		'''          <li> for each proxy interface, {@code intf},
		'''               the caller's class loader is not the same as or an
		'''               ancestor of the class loader for {@code intf} and
		'''               invocation of {@link SecurityManager#checkPackageAccess
		'''               s.checkPackageAccess()} denies access to {@code intf};</li>
		'''          <li> any of the given proxy interfaces is non-public and the
		'''               caller class is not in the same <seealso cref="Package runtime package"/>
		'''               as the non-public interface and the invocation of
		'''               <seealso cref="SecurityManager#checkPermission s.checkPermission"/> with
		'''               {@code ReflectPermission("newProxyInPackage.{package name}")}
		'''               permission denies access.</li>
		'''          </ul> </exception>
		''' <exception cref="NullPointerException"> if the {@code interfaces} array
		'''          argument or any of its elements are {@code null}, or
		'''          if the invocation handler, {@code h}, is
		'''          {@code null} </exception>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
		Public Shared Function newProxyInstance(ByVal loader As ClassLoader, ByVal interfaces As Class(), ByVal h As InvocationHandler) As Object
			java.util.Objects.requireNonNull(h)

			Dim intfs As Class() = interfaces.clone()
			Dim sm As SecurityManager = System.securityManager
			If sm IsNot Nothing Then checkProxyAccess(sun.reflect.Reflection.callerClass, loader, intfs)

	'        
	'         * Look up or generate the designated proxy class.
	'         
			Dim cl As Class = getProxyClass0(loader, intfs)

	'        
	'         * Invoke its constructor with the designated invocation handler.
	'         
			Try
				If sm IsNot Nothing Then checkNewProxyPermission(sun.reflect.Reflection.callerClass, cl)

'JAVA TO VB CONVERTER TODO TASK: Java wildcard generics are not converted to .NET:
				Dim cons As Constructor(Of ?) = cl.getConstructor(constructorParams)
				Dim ih As InvocationHandler = h
				If Not Modifier.isPublic(cl.modifiers) Then java.security.AccessController.doPrivileged(New PrivilegedActionAnonymousInnerClassHelper(Of T)
				Return cons.newInstance(New Object(){h})
'JAVA TO VB CONVERTER TODO TASK: There is no equivalent in VB to Java 'multi-catch' syntax:
			Catch IllegalAccessException Or InstantiationException e
				Throw New InternalError(e.ToString(), e)
			Catch e As InvocationTargetException
				Dim t As Throwable = e.InnerException
				If TypeOf t Is RuntimeException Then
					Throw CType(t, RuntimeException)
				Else
					Throw New InternalError(t.ToString(), t)
				End If
			Catch e As NoSuchMethodException
				Throw New InternalError(e.ToString(), e)
			End Try
		End Function

		Private Class PrivilegedActionAnonymousInnerClassHelper(Of T)
			Implements java.security.PrivilegedAction(Of T)

			Public Overridable Function run() As Void
				cons.accessible = True
				Return Nothing
			End Function
		End Class

		Private Shared Sub checkNewProxyPermission(ByVal caller As Class, ByVal proxyClass As Class)
			Dim sm As SecurityManager = System.securityManager
			If sm IsNot Nothing Then
				If sun.reflect.misc.ReflectUtil.isNonPublicProxyClass(proxyClass) Then
					Dim ccl As ClassLoader = caller.classLoader
					Dim pcl As ClassLoader = proxyClass.classLoader

					' do permission check if the caller is in a different runtime package
					' of the proxy class
					Dim n As Integer = proxyClass.name.LastIndexOf("."c)
					Dim pkg As String = If(n = -1, "", proxyClass.name.Substring(0, n))

					n = caller.name.LastIndexOf("."c)
					Dim callerPkg As String = If(n = -1, "", caller.name.Substring(0, n))

					If pcl IsNot ccl OrElse (Not pkg.Equals(callerPkg)) Then sm.checkPermission(New ReflectPermission("newProxyInPackage." & pkg))
				End If
			End If
		End Sub

		''' <summary>
		''' Returns true if and only if the specified class was dynamically
		''' generated to be a proxy class using the {@code getProxyClass}
		''' method or the {@code newProxyInstance} method.
		''' 
		''' <p>The reliability of this method is important for the ability
		''' to use it to make security decisions, so its implementation should
		''' not just test if the class in question extends {@code Proxy}.
		''' </summary>
		''' <param name="cl"> the class to test </param>
		''' <returns>  {@code true} if the class is a proxy class and
		'''          {@code false} otherwise </returns>
		''' <exception cref="NullPointerException"> if {@code cl} is {@code null} </exception>
		Public Shared Function isProxyClass(ByVal cl As Class) As Boolean
			Return cl.IsSubclassOf(GetType(Proxy)) AndAlso proxyClassCache.containsValue(cl)
		End Function

		''' <summary>
		''' Returns the invocation handler for the specified proxy instance.
		''' </summary>
		''' <param name="proxy"> the proxy instance to return the invocation handler for </param>
		''' <returns>  the invocation handler for the proxy instance </returns>
		''' <exception cref="IllegalArgumentException"> if the argument is not a
		'''          proxy instance </exception>
		''' <exception cref="SecurityException"> if a security manager, <em>s</em>, is present
		'''          and the caller's class loader is not the same as or an
		'''          ancestor of the class loader for the invocation handler
		'''          and invocation of {@link SecurityManager#checkPackageAccess
		'''          s.checkPackageAccess()} denies access to the invocation
		'''          handler's class. </exception>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
		Public Shared Function getInvocationHandler(ByVal proxy_Renamed As Object) As InvocationHandler
	'        
	'         * Verify that the object is actually a proxy instance.
	'         
			If Not isProxyClass(proxy_Renamed.GetType()) Then Throw New IllegalArgumentException("not a proxy instance")

			Dim p As Proxy = CType(proxy_Renamed, Proxy)
			Dim ih As InvocationHandler = p.h
			If System.securityManager IsNot Nothing Then
				Dim ihClass As Class = ih.GetType()
				Dim caller As Class = sun.reflect.Reflection.callerClass
				If sun.reflect.misc.ReflectUtil.needsPackageAccessCheck(caller.classLoader, ihClass.classLoader) Then sun.reflect.misc.ReflectUtil.checkPackageAccess(ihClass)
			End If

			Return ih
		End Function

'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")> _
		Private Shared Function defineClass0(ByVal loader As ClassLoader, ByVal name As String, ByVal b As SByte(), ByVal [off] As Integer, ByVal len As Integer) As Class
		End Function
	End Class

End Namespace