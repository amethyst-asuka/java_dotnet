'
' * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
' * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' 

Namespace java.util


	''' <summary>
	''' A generator of uniform pseudorandom values applicable for use in
	''' (among other contexts) isolated parallel computations that may
	''' generate subtasks. Class {@code SplittableRandom} supports methods for
	''' producing pseudorandom numbers of type {@code int}, {@code long},
	''' and {@code double} with similar usages as for class
	''' <seealso cref="java.util.Random"/> but differs in the following ways:
	''' 
	''' <ul>
	''' 
	''' <li>Series of generated values pass the DieHarder suite testing
	''' independence and uniformity properties of random number generators.
	''' (Most recently validated with <a
	''' href="http://www.phy.duke.edu/~rgb/General/dieharder.php"> version
	''' 3.31.1</a>.) These tests validate only the methods for certain
	''' types and ranges, but similar properties are expected to hold, at
	''' least approximately, for others as well. The <em>period</em>
	''' (length of any series of generated values before it repeats) is at
	''' least 2<sup>64</sup>. </li>
	''' 
	''' <li> Method <seealso cref="#split"/> constructs and returns a new
	''' SplittableRandom instance that shares no mutable state with the
	''' current instance. However, with very high probability, the
	''' values collectively generated by the two objects have the same
	''' statistical properties as if the same quantity of values were
	''' generated by a single thread using a single {@code
	''' SplittableRandom} object.  </li>
	''' 
	''' <li>Instances of SplittableRandom are <em>not</em> thread-safe.
	''' They are designed to be split, not shared, across threads. For
	''' example, a {@link java.util.concurrent.ForkJoinTask
	''' fork/join-style} computation using random numbers might include a
	''' construction of the form {@code new
	''' Subtask(aSplittableRandom.split()).fork()}.
	''' 
	''' <li>This class provides additional methods for generating random
	''' streams, that employ the above techniques when used in {@code
	''' stream.parallel()} mode.</li>
	''' 
	''' </ul>
	''' 
	''' <p>Instances of {@code SplittableRandom} are not cryptographically
	''' secure.  Consider instead using <seealso cref="java.security.SecureRandom"/>
	''' in security-sensitive applications. Additionally,
	''' default-constructed instances do not use a cryptographically random
	''' seed unless the <seealso cref="System#getProperty system property"/>
	''' {@code java.util.secureRandomSeed} is set to {@code true}.
	''' 
	''' @author  Guy Steele
	''' @author  Doug Lea
	''' @since   1.8
	''' </summary>
	Public NotInheritable Class SplittableRandom

	'    
	'     * Implementation Overview.
	'     *
	'     * This algorithm was inspired by the "DotMix" algorithm by
	'     * Leiserson, Schardl, and Sukha "Deterministic Parallel
	'     * Random-Number Generation for Dynamic-Multithreading Platforms",
	'     * PPoPP 2012, as well as those in "Parallel random numbers: as
	'     * easy as 1, 2, 3" by Salmon, Morae, Dror, and Shaw, SC 2011.  It
	'     * differs mainly in simplifying and cheapening operations.
	'     *
	'     * The primary update step (method nextSeed()) is to add a
	'     * constant ("gamma") to the current (64 bit) seed, forming a
	'     * simple sequence.  The seed and the gamma values for any two
	'     * SplittableRandom instances are highly likely to be different.
	'     *
	'     * Methods nextLong, nextInt, and derivatives do not return the
	'     * sequence (seed) values, but instead a hash-like bit-mix of
	'     * their bits, producing more independently distributed sequences.
	'     * For nextLong, the mix64 function is based on David Stafford's
	'     * (http://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html)
	'     * "Mix13" variant of the "64-bit finalizer" function in Austin
	'     * Appleby's MurmurHash3 algorithm (see
	'     * http://code.google.com/p/smhasher/wiki/MurmurHash3). The mix32
	'     * function is based on Stafford's Mix04 mix function, but returns
	'     * the upper 32 bits cast as int.
	'     *
	'     * The split operation uses the current generator to form the seed
	'     * and gamma for another SplittableRandom.  To conservatively
	'     * avoid potential correlations between seed and value generation,
	'     * gamma selection (method mixGamma) uses different
	'     * (Murmurhash3's) mix constants.  To avoid potential weaknesses
	'     * in bit-mixing transformations, we restrict gammas to odd values
	'     * with at least 24 0-1 or 1-0 bit transitions.  Rather than
	'     * rejecting candidates with too few or too many bits set, method
	'     * mixGamma flips some bits (which has the effect of mapping at
	'     * most 4 to any given gamma value).  This reduces the effective
	'     * set of 64bit odd gamma values by about 2%, and serves as an
	'     * automated screening for sequence constant selection that is
	'     * left as an empirical decision in some other hashing and crypto
	'     * algorithms.
	'     *
	'     * The resulting generator thus transforms a sequence in which
	'     * (typically) many bits change on each step, with an inexpensive
	'     * mixer with good (but less than cryptographically secure)
	'     * avalanching.
	'     *
	'     * The default (no-argument) constructor, in essence, invokes
	'     * split() for a common "defaultGen" SplittableRandom.  Unlike
	'     * other cases, this split must be performed in a thread-safe
	'     * manner, so we use an AtomicLong to represent the seed rather
	'     * than use an explicit SplittableRandom. To bootstrap the
	'     * defaultGen, we start off using a seed based on current time
	'     * unless the java.util.secureRandomSeed property is set. This
	'     * serves as a slimmed-down (and insecure) variant of SecureRandom
	'     * that also avoids stalls that may occur when using /dev/random.
	'     *
	'     * It is a relatively simple matter to apply the basic design here
	'     * to use 128 bit seeds. However, emulating 128bit arithmetic and
	'     * carrying around twice the state add more overhead than appears
	'     * warranted for current usages.
	'     *
	'     * File organization: First the non-public methods that constitute
	'     * the main algorithm, then the main public methods, followed by
	'     * some custom spliterator classes needed for stream methods.
	'     

		''' <summary>
		''' The golden ratio scaled to 64bits, used as the initial gamma
		''' value for (unsplit) SplittableRandoms.
		''' </summary>
		Private Const GOLDEN_GAMMA As Long = &H9e3779b97f4a7c15L

		''' <summary>
		''' The least non-zero value returned by nextDouble(). This value
		''' is scaled by a random value of 53 bits to produce a result.
		''' </summary>
		Private Shared ReadOnly DOUBLE_UNIT As Double = &H1.0p-53 ' 1.0 / (1L << 53);

		''' <summary>
		''' The seed. Updated only via method nextSeed.
		''' </summary>
		Private seed As Long

		''' <summary>
		''' The step value.
		''' </summary>
		Private ReadOnly gamma As Long

		''' <summary>
		''' Internal constructor used by all others except default constructor.
		''' </summary>
		Private Sub New(ByVal seed As Long, ByVal gamma As Long)
			Me.seed = seed
			Me.gamma = gamma
		End Sub

		''' <summary>
		''' Computes Stafford variant 13 of 64bit mix function.
		''' </summary>
		Private Shared Function mix64(ByVal z As Long) As Long
			z = (z Xor (CLng(CULng(z) >> 30))) * &Hbf58476R1ce4e5b9L
			z = (z Xor (CLng(CULng(z) >> 27))) * &H94d049bb133111ebL
			Return z Xor (CLng(CULng(z) >> 31))
		End Function

		''' <summary>
		''' Returns the 32 high bits of Stafford variant 4 mix64 function as int.
		''' </summary>
		Private Shared Function mix32(ByVal z As Long) As Integer
			z = (z Xor (CLng(CULng(z) >> 33))) * &H62a9R9ed799705f5L
			Return CInt(CInt(CUInt(((z Xor (CLng(CULng(z) >> 28))) * &Hcb24R0a5c88c35b3L)) >> 32))
		End Function

		''' <summary>
		''' Returns the gamma value to use for a new split instance.
		''' </summary>
		Private Shared Function mixGamma(ByVal z As Long) As Long
			z = (z Xor (CLng(CULng(z) >> 33))) * &Hff51afd7ed558ccdL ' MurmurHash3 mix constants
			z = (z Xor (CLng(CULng(z) >> 33))) * &Hc4ceb9fe1a85ec53L
			z = (z Xor (CLng(CULng(z) >> 33))) Or 1L ' force to be odd
			Dim n As Integer = Long.bitCount(z Xor (CLng(CULng(z) >> 1))) ' ensure enough transitions
			Return If(n < 24, z Xor &HaaaaaaaaaaaaaaaaL, z)
		End Function

		''' <summary>
		''' Adds gamma to seed.
		''' </summary>
		Private Function nextSeed() As Long
				seed += gamma
				Return seed
		End Function

		''' <summary>
		''' The seed generator for default constructors.
		''' </summary>
		Private Shared ReadOnly defaultGen As New java.util.concurrent.atomic.AtomicLong(initialSeed())

		Private Shared Function initialSeed() As Long
			Dim pp As String = java.security.AccessController.doPrivileged(New sun.security.action.GetPropertyAction("java.util.secureRandomSeed"))
			If pp IsNot Nothing AndAlso pp.equalsIgnoreCase("true") Then
				Dim seedBytes As SByte() = java.security.SecureRandom.getSeed(8)
				Dim s As Long = CLng(seedBytes(0)) And &HffL
				For i As Integer = 1 To 7
					s = (s << 8) Or (CLng(seedBytes(i)) And &HffL)
				Next i
				Return s
			End If
			Return (mix64(System.currentTimeMillis()) Xor mix64(System.nanoTime()))
		End Function

		' IllegalArgumentException messages
		Friend Const BadBound As String = "bound must be positive"
		Friend Const BadRange As String = "bound must be greater than origin"
		Friend Const BadSize As String = "size must be non-negative"

	'    
	'     * Internal versions of nextX methods used by streams, as well as
	'     * the public nextX(origin, bound) methods.  These exist mainly to
	'     * avoid the need for multiple versions of stream spliterators
	'     * across the different exported forms of streams.
	'     

		''' <summary>
		''' The form of nextLong used by LongStream Spliterators.  If
		''' origin is greater than bound, acts as unbounded form of
		''' nextLong, else as bounded form.
		''' </summary>
		''' <param name="origin"> the least value, unless greater than bound </param>
		''' <param name="bound"> the upper bound (exclusive), must not equal origin </param>
		''' <returns> a pseudorandom value </returns>
		Friend Function internalNextLong(ByVal origin As Long, ByVal bound As Long) As Long
	'        
	'         * Four Cases:
	'         *
	'         * 1. If the arguments indicate unbounded form, act as
	'         * nextLong().
	'         *
	'         * 2. If the range is an exact power of two, apply the
	'         * associated bit mask.
	'         *
	'         * 3. If the range is positive, loop to avoid potential bias
	'         * when the implicit nextLong() bound (2<sup>64</sup>) is not
	'         * evenly divisible by the range. The loop rejects candidates
	'         * computed from otherwise over-represented values.  The
	'         * expected number of iterations under an ideal generator
	'         * varies from 1 to 2, depending on the bound. The loop itself
	'         * takes an unlovable form. Because the first candidate is
	'         * already available, we need a break-in-the-middle
	'         * construction, which is concisely but cryptically performed
	'         * within the while-condition of a body-less for loop.
	'         *
	'         * 4. Otherwise, the range cannot be represented as a positive
	'         * long.  The loop repeatedly generates unbounded longs until
	'         * obtaining a candidate meeting constraints (with an expected
	'         * number of iterations of less than two).
	'         

			Dim r As Long = mix64(nextSeed())
			If origin < bound Then
				Dim n As Long = bound - origin, m As Long = n - 1
				If (n And m) = 0L Then ' power of two
					r = (r And m) + origin
				ElseIf n > 0L Then ' reject over-represented candidates
					Dim u As Long = CLng(CULng(r) >> 1)
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
					Do While u + m - (r = u Mod n) < 0L ' retry -  rejection check -  ensure nonnegative

						u = CInt(CUInt(mix64(nextSeed())) >> 1)
					Loop
					r += origin
				Else ' range not representable as long
					Do While r < origin OrElse r >= bound
						r = mix64(nextSeed())
					Loop
				End If
			End If
			Return r
		End Function

		''' <summary>
		''' The form of nextInt used by IntStream Spliterators.
		''' Exactly the same as long version, except for types.
		''' </summary>
		''' <param name="origin"> the least value, unless greater than bound </param>
		''' <param name="bound"> the upper bound (exclusive), must not equal origin </param>
		''' <returns> a pseudorandom value </returns>
		Friend Function internalNextInt(ByVal origin As Integer, ByVal bound As Integer) As Integer
			Dim r As Integer = mix32(nextSeed())
			If origin < bound Then
				Dim n As Integer = bound - origin, m As Integer = n - 1
				If (n And m) = 0 Then
					r = (r And m) + origin
				ElseIf n > 0 Then
					Dim u As Integer = CInt(CUInt(r) >> 1)
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
					Do While u + m - (r = u Mod n) < 0

						u = CInt(CUInt(mix32(nextSeed())) >> 1)
					Loop
					r += origin
				Else
					Do While r < origin OrElse r >= bound
						r = mix32(nextSeed())
					Loop
				End If
			End If
			Return r
		End Function

		''' <summary>
		''' The form of nextDouble used by DoubleStream Spliterators.
		''' </summary>
		''' <param name="origin"> the least value, unless greater than bound </param>
		''' <param name="bound"> the upper bound (exclusive), must not equal origin </param>
		''' <returns> a pseudorandom value </returns>
		Friend Function internalNextDouble(ByVal origin As Double, ByVal bound As Double) As Double
			Dim r As Double = (CInt(CUInt(nextLong()) >> 11)) * DOUBLE_UNIT
			If origin < bound Then
				r = r * (bound - origin) + origin
				If r >= bound Then ' correct for rounding r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1)
			End If
			Return r
		End Function

		' ---------------- public methods ---------------- 

		''' <summary>
		''' Creates a new SplittableRandom instance using the specified
		''' initial seed. SplittableRandom instances created with the same
		''' seed in the same program generate identical sequences of values.
		''' </summary>
		''' <param name="seed"> the initial seed </param>
		Public Sub New(ByVal seed As Long)
			Me.New(seed, GOLDEN_GAMMA)
		End Sub

		''' <summary>
		''' Creates a new SplittableRandom instance that is likely to
		''' generate sequences of values that are statistically independent
		''' of those of any other instances in the current program; and
		''' may, and typically does, vary across program invocations.
		''' </summary>
		Public Sub New() ' emulate defaultGen.split()
			Dim s As Long = defaultGen.getAndAdd(2 * GOLDEN_GAMMA)
			Me.seed = mix64(s)
			Me.gamma = mixGamma(s + GOLDEN_GAMMA)
		End Sub

		''' <summary>
		''' Constructs and returns a new SplittableRandom instance that
		''' shares no mutable state with this instance. However, with very
		''' high probability, the set of values collectively generated by
		''' the two objects has the same statistical properties as if the
		''' same quantity of values were generated by a single thread using
		''' a single SplittableRandom object.  Either or both of the two
		''' objects may be further split using the {@code split()} method,
		''' and the same expected statistical properties apply to the
		''' entire set of generators constructed by such recursive
		''' splitting.
		''' </summary>
		''' <returns> the new SplittableRandom instance </returns>
		Public Function split() As SplittableRandom
			Return New SplittableRandom(nextLong(), mixGamma(nextSeed()))
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code int} value.
		''' </summary>
		''' <returns> a pseudorandom {@code int} value </returns>
		Public Function nextInt() As Integer
			Return mix32(nextSeed())
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code int} value between zero (inclusive)
		''' and the specified bound (exclusive).
		''' </summary>
		''' <param name="bound"> the upper bound (exclusive).  Must be positive. </param>
		''' <returns> a pseudorandom {@code int} value between zero
		'''         (inclusive) and the bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code bound} is not positive </exception>
		Public Function nextInt(ByVal bound As Integer) As Integer
			If bound <= 0 Then Throw New IllegalArgumentException(BadBound)
			' Specialize internalNextInt for origin 0
			Dim r As Integer = mix32(nextSeed())
			Dim m As Integer = bound - 1
			If (bound And m) = 0 Then ' power of two
				r = r And m
			Else ' reject over-represented candidates
				Dim u As Integer = CInt(CUInt(r) >> 1)
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
				Do While u + m - (r = u Mod bound) < 0

					u = CInt(CUInt(mix32(nextSeed())) >> 1)
				Loop
			End If
			Return r
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code int} value between the specified
		''' origin (inclusive) and the specified bound (exclusive).
		''' </summary>
		''' <param name="origin"> the least value returned </param>
		''' <param name="bound"> the upper bound (exclusive) </param>
		''' <returns> a pseudorandom {@code int} value between the origin
		'''         (inclusive) and the bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code origin} is greater than
		'''         or equal to {@code bound} </exception>
		Public Function nextInt(ByVal origin As Integer, ByVal bound As Integer) As Integer
			If origin >= bound Then Throw New IllegalArgumentException(BadRange)
			Return internalNextInt(origin, bound)
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code long} value.
		''' </summary>
		''' <returns> a pseudorandom {@code long} value </returns>
		Public Function nextLong() As Long
			Return mix64(nextSeed())
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code long} value between zero (inclusive)
		''' and the specified bound (exclusive).
		''' </summary>
		''' <param name="bound"> the upper bound (exclusive).  Must be positive. </param>
		''' <returns> a pseudorandom {@code long} value between zero
		'''         (inclusive) and the bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code bound} is not positive </exception>
		Public Function nextLong(ByVal bound As Long) As Long
			If bound <= 0 Then Throw New IllegalArgumentException(BadBound)
			' Specialize internalNextLong for origin 0
			Dim r As Long = mix64(nextSeed())
			Dim m As Long = bound - 1
			If (bound And m) = 0L Then ' power of two
				r = r And m
			Else ' reject over-represented candidates
				Dim u As Long = CLng(CULng(r) >> 1)
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
				Do While u + m - (r = u Mod bound) < 0L

					u = CInt(CUInt(mix64(nextSeed())) >> 1)
				Loop
			End If
			Return r
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code long} value between the specified
		''' origin (inclusive) and the specified bound (exclusive).
		''' </summary>
		''' <param name="origin"> the least value returned </param>
		''' <param name="bound"> the upper bound (exclusive) </param>
		''' <returns> a pseudorandom {@code long} value between the origin
		'''         (inclusive) and the bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code origin} is greater than
		'''         or equal to {@code bound} </exception>
		Public Function nextLong(ByVal origin As Long, ByVal bound As Long) As Long
			If origin >= bound Then Throw New IllegalArgumentException(BadRange)
			Return internalNextLong(origin, bound)
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code double} value between zero
		''' (inclusive) and one (exclusive).
		''' </summary>
		''' <returns> a pseudorandom {@code double} value between zero
		'''         (inclusive) and one (exclusive) </returns>
		Public Function nextDouble() As Double
			Return (CInt(CUInt(mix64(nextSeed())) >> 11)) * DOUBLE_UNIT
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code double} value between 0.0
		''' (inclusive) and the specified bound (exclusive).
		''' </summary>
		''' <param name="bound"> the upper bound (exclusive).  Must be positive. </param>
		''' <returns> a pseudorandom {@code double} value between zero
		'''         (inclusive) and the bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code bound} is not positive </exception>
		Public Function nextDouble(ByVal bound As Double) As Double
			If Not(bound > 0.0) Then Throw New IllegalArgumentException(BadBound)
			Dim result As Double = (CInt(CUInt(mix64(nextSeed())) >> 11)) * DOUBLE_UNIT * bound
			Return If(result < bound, result, Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1)) ' correct for rounding
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code double} value between the specified
		''' origin (inclusive) and bound (exclusive).
		''' </summary>
		''' <param name="origin"> the least value returned </param>
		''' <param name="bound"> the upper bound (exclusive) </param>
		''' <returns> a pseudorandom {@code double} value between the origin
		'''         (inclusive) and the bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code origin} is greater than
		'''         or equal to {@code bound} </exception>
		Public Function nextDouble(ByVal origin As Double, ByVal bound As Double) As Double
			If Not(origin < bound) Then Throw New IllegalArgumentException(BadRange)
			Return internalNextDouble(origin, bound)
		End Function

		''' <summary>
		''' Returns a pseudorandom {@code boolean} value.
		''' </summary>
		''' <returns> a pseudorandom {@code boolean} value </returns>
		Public Function nextBoolean() As Boolean
			Return mix32(nextSeed()) < 0
		End Function

		' stream methods, coded in a way intended to better isolate for
		' maintenance purposes the small differences across forms.

		''' <summary>
		''' Returns a stream producing the given {@code streamSize} number
		''' of pseudorandom {@code int} values from this generator and/or
		''' one split from it.
		''' </summary>
		''' <param name="streamSize"> the number of values to generate </param>
		''' <returns> a stream of pseudorandom {@code int} values </returns>
		''' <exception cref="IllegalArgumentException"> if {@code streamSize} is
		'''         less than zero </exception>
		Public Function ints(ByVal streamSize As Long) As java.util.stream.IntStream
			If streamSize < 0L Then Throw New IllegalArgumentException(BadSize)
			Return java.util.stream.StreamSupport.intStream(New RandomIntsSpliterator(Me, 0L, streamSize, Integer.MaxValue, 0), False)
		End Function

		''' <summary>
		''' Returns an effectively unlimited stream of pseudorandom {@code int}
		''' values from this generator and/or one split from it.
		''' 
		''' @implNote This method is implemented to be equivalent to {@code
		''' ints(Long.MAX_VALUE)}.
		''' </summary>
		''' <returns> a stream of pseudorandom {@code int} values </returns>
		Public Function ints() As java.util.stream.IntStream
			Return java.util.stream.StreamSupport.intStream(New RandomIntsSpliterator(Me, 0L, Long.MaxValue, Integer.MaxValue, 0), False)
		End Function

		''' <summary>
		''' Returns a stream producing the given {@code streamSize} number
		''' of pseudorandom {@code int} values from this generator and/or one split
		''' from it; each value conforms to the given origin (inclusive) and bound
		''' (exclusive).
		''' </summary>
		''' <param name="streamSize"> the number of values to generate </param>
		''' <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		''' <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		''' <returns> a stream of pseudorandom {@code int} values,
		'''         each with the given origin (inclusive) and bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code streamSize} is
		'''         less than zero, or {@code randomNumberOrigin}
		'''         is greater than or equal to {@code randomNumberBound} </exception>
		Public Function ints(ByVal streamSize As Long, ByVal randomNumberOrigin As Integer, ByVal randomNumberBound As Integer) As java.util.stream.IntStream
			If streamSize < 0L Then Throw New IllegalArgumentException(BadSize)
			If randomNumberOrigin >= randomNumberBound Then Throw New IllegalArgumentException(BadRange)
			Return java.util.stream.StreamSupport.intStream(New RandomIntsSpliterator(Me, 0L, streamSize, randomNumberOrigin, randomNumberBound), False)
		End Function

		''' <summary>
		''' Returns an effectively unlimited stream of pseudorandom {@code
		''' int} values from this generator and/or one split from it; each value
		''' conforms to the given origin (inclusive) and bound (exclusive).
		''' 
		''' @implNote This method is implemented to be equivalent to {@code
		''' ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
		''' </summary>
		''' <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		''' <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		''' <returns> a stream of pseudorandom {@code int} values,
		'''         each with the given origin (inclusive) and bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		'''         is greater than or equal to {@code randomNumberBound} </exception>
		Public Function ints(ByVal randomNumberOrigin As Integer, ByVal randomNumberBound As Integer) As java.util.stream.IntStream
			If randomNumberOrigin >= randomNumberBound Then Throw New IllegalArgumentException(BadRange)
			Return java.util.stream.StreamSupport.intStream(New RandomIntsSpliterator(Me, 0L, Long.MaxValue, randomNumberOrigin, randomNumberBound), False)
		End Function

		''' <summary>
		''' Returns a stream producing the given {@code streamSize} number
		''' of pseudorandom {@code long} values from this generator and/or
		''' one split from it.
		''' </summary>
		''' <param name="streamSize"> the number of values to generate </param>
		''' <returns> a stream of pseudorandom {@code long} values </returns>
		''' <exception cref="IllegalArgumentException"> if {@code streamSize} is
		'''         less than zero </exception>
		Public Function longs(ByVal streamSize As Long) As java.util.stream.LongStream
			If streamSize < 0L Then Throw New IllegalArgumentException(BadSize)
			Return java.util.stream.StreamSupport.longStream(New RandomLongsSpliterator(Me, 0L, streamSize, Long.MaxValue, 0L), False)
		End Function

		''' <summary>
		''' Returns an effectively unlimited stream of pseudorandom {@code
		''' long} values from this generator and/or one split from it.
		''' 
		''' @implNote This method is implemented to be equivalent to {@code
		''' longs(Long.MAX_VALUE)}.
		''' </summary>
		''' <returns> a stream of pseudorandom {@code long} values </returns>
		Public Function longs() As java.util.stream.LongStream
			Return java.util.stream.StreamSupport.longStream(New RandomLongsSpliterator(Me, 0L, Long.MaxValue, Long.MaxValue, 0L), False)
		End Function

		''' <summary>
		''' Returns a stream producing the given {@code streamSize} number of
		''' pseudorandom {@code long} values from this generator and/or one split
		''' from it; each value conforms to the given origin (inclusive) and bound
		''' (exclusive).
		''' </summary>
		''' <param name="streamSize"> the number of values to generate </param>
		''' <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		''' <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		''' <returns> a stream of pseudorandom {@code long} values,
		'''         each with the given origin (inclusive) and bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code streamSize} is
		'''         less than zero, or {@code randomNumberOrigin}
		'''         is greater than or equal to {@code randomNumberBound} </exception>
		Public Function longs(ByVal streamSize As Long, ByVal randomNumberOrigin As Long, ByVal randomNumberBound As Long) As java.util.stream.LongStream
			If streamSize < 0L Then Throw New IllegalArgumentException(BadSize)
			If randomNumberOrigin >= randomNumberBound Then Throw New IllegalArgumentException(BadRange)
			Return java.util.stream.StreamSupport.longStream(New RandomLongsSpliterator(Me, 0L, streamSize, randomNumberOrigin, randomNumberBound), False)
		End Function

		''' <summary>
		''' Returns an effectively unlimited stream of pseudorandom {@code
		''' long} values from this generator and/or one split from it; each value
		''' conforms to the given origin (inclusive) and bound (exclusive).
		''' 
		''' @implNote This method is implemented to be equivalent to {@code
		''' longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
		''' </summary>
		''' <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		''' <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		''' <returns> a stream of pseudorandom {@code long} values,
		'''         each with the given origin (inclusive) and bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		'''         is greater than or equal to {@code randomNumberBound} </exception>
		Public Function longs(ByVal randomNumberOrigin As Long, ByVal randomNumberBound As Long) As java.util.stream.LongStream
			If randomNumberOrigin >= randomNumberBound Then Throw New IllegalArgumentException(BadRange)
			Return java.util.stream.StreamSupport.longStream(New RandomLongsSpliterator(Me, 0L, Long.MaxValue, randomNumberOrigin, randomNumberBound), False)
		End Function

		''' <summary>
		''' Returns a stream producing the given {@code streamSize} number of
		''' pseudorandom {@code double} values from this generator and/or one split
		''' from it; each value is between zero (inclusive) and one (exclusive).
		''' </summary>
		''' <param name="streamSize"> the number of values to generate </param>
		''' <returns> a stream of {@code double} values </returns>
		''' <exception cref="IllegalArgumentException"> if {@code streamSize} is
		'''         less than zero </exception>
		Public Function doubles(ByVal streamSize As Long) As java.util.stream.DoubleStream
			If streamSize < 0L Then Throw New IllegalArgumentException(BadSize)
			Return java.util.stream.StreamSupport.doubleStream(New RandomDoublesSpliterator(Me, 0L, streamSize, Double.MaxValue, 0.0), False)
		End Function

		''' <summary>
		''' Returns an effectively unlimited stream of pseudorandom {@code
		''' double} values from this generator and/or one split from it; each value
		''' is between zero (inclusive) and one (exclusive).
		''' 
		''' @implNote This method is implemented to be equivalent to {@code
		''' doubles(Long.MAX_VALUE)}.
		''' </summary>
		''' <returns> a stream of pseudorandom {@code double} values </returns>
		Public Function doubles() As java.util.stream.DoubleStream
			Return java.util.stream.StreamSupport.doubleStream(New RandomDoublesSpliterator(Me, 0L, Long.MaxValue, Double.MaxValue, 0.0), False)
		End Function

		''' <summary>
		''' Returns a stream producing the given {@code streamSize} number of
		''' pseudorandom {@code double} values from this generator and/or one split
		''' from it; each value conforms to the given origin (inclusive) and bound
		''' (exclusive).
		''' </summary>
		''' <param name="streamSize"> the number of values to generate </param>
		''' <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		''' <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		''' <returns> a stream of pseudorandom {@code double} values,
		'''         each with the given origin (inclusive) and bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code streamSize} is
		'''         less than zero </exception>
		''' <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		'''         is greater than or equal to {@code randomNumberBound} </exception>
		Public Function doubles(ByVal streamSize As Long, ByVal randomNumberOrigin As Double, ByVal randomNumberBound As Double) As java.util.stream.DoubleStream
			If streamSize < 0L Then Throw New IllegalArgumentException(BadSize)
			If Not(randomNumberOrigin < randomNumberBound) Then Throw New IllegalArgumentException(BadRange)
			Return java.util.stream.StreamSupport.doubleStream(New RandomDoublesSpliterator(Me, 0L, streamSize, randomNumberOrigin, randomNumberBound), False)
		End Function

		''' <summary>
		''' Returns an effectively unlimited stream of pseudorandom {@code
		''' double} values from this generator and/or one split from it; each value
		''' conforms to the given origin (inclusive) and bound (exclusive).
		''' 
		''' @implNote This method is implemented to be equivalent to {@code
		''' doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
		''' </summary>
		''' <param name="randomNumberOrigin"> the origin (inclusive) of each random value </param>
		''' <param name="randomNumberBound"> the bound (exclusive) of each random value </param>
		''' <returns> a stream of pseudorandom {@code double} values,
		'''         each with the given origin (inclusive) and bound (exclusive) </returns>
		''' <exception cref="IllegalArgumentException"> if {@code randomNumberOrigin}
		'''         is greater than or equal to {@code randomNumberBound} </exception>
		Public Function doubles(ByVal randomNumberOrigin As Double, ByVal randomNumberBound As Double) As java.util.stream.DoubleStream
			If Not(randomNumberOrigin < randomNumberBound) Then Throw New IllegalArgumentException(BadRange)
			Return java.util.stream.StreamSupport.doubleStream(New RandomDoublesSpliterator(Me, 0L, Long.MaxValue, randomNumberOrigin, randomNumberBound), False)
		End Function

		''' <summary>
		''' Spliterator for int streams.  We multiplex the four int
		''' versions into one class by treating a bound less than origin as
		''' unbounded, and also by treating "infinite" as equivalent to
		''' Long.MAX_VALUE. For splits, it uses the standard divide-by-two
		''' approach. The long and double versions of this class are
		''' identical except for types.
		''' </summary>
		Friend NotInheritable Class RandomIntsSpliterator
			Implements Spliterator.OfInt

			Friend ReadOnly rng As SplittableRandom
			Friend index As Long
			Friend ReadOnly fence As Long
			Friend ReadOnly origin As Integer
			Friend ReadOnly bound As Integer
			Friend Sub New(ByVal rng As SplittableRandom, ByVal index As Long, ByVal fence As Long, ByVal origin As Integer, ByVal bound As Integer)
				Me.rng = rng
				Me.index = index
				Me.fence = fence
				Me.origin = origin
				Me.bound = bound
			End Sub

			Public Function trySplit() As RandomIntsSpliterator
				Dim i As Long = index, m As Long = CInt(CUInt((i + fence)) >> 1)
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
				Return If(m <= i, Nothing, New RandomIntsSpliterator(rng.Split(), i, index = m, origin, bound))
			End Function

			Public Function estimateSize() As Long
				Return fence - index
			End Function

			Public Function characteristics() As Integer
				Return (Spliterator.SIZED Or Spliterator.SUBSIZED Or Spliterator.NONNULL Or Spliterator.IMMUTABLE)
			End Function

			Public Function tryAdvance(ByVal consumer As java.util.function.IntConsumer) As Boolean
				If consumer Is Nothing Then Throw New NullPointerException
				Dim i As Long = index, f As Long = fence
				If i < f Then
					consumer.accept(rng.internalNextInt(origin, bound))
					index = i + 1
					Return True
				End If
				Return False
			End Function

			Public Sub forEachRemaining(ByVal consumer As java.util.function.IntConsumer)
				If consumer Is Nothing Then Throw New NullPointerException
				Dim i As Long = index, f As Long = fence
				If i < f Then
					index = f
					Dim r As SplittableRandom = rng
					Dim o As Integer = origin, b As Integer = bound
					Do
						consumer.accept(r.internalNextInt(o, b))
						i += 1
					Loop While i < f
				End If
			End Sub
		End Class

		''' <summary>
		''' Spliterator for long streams.
		''' </summary>
		Friend NotInheritable Class RandomLongsSpliterator
			Implements Spliterator.OfLong

			Friend ReadOnly rng As SplittableRandom
			Friend index As Long
			Friend ReadOnly fence As Long
			Friend ReadOnly origin As Long
			Friend ReadOnly bound As Long
			Friend Sub New(ByVal rng As SplittableRandom, ByVal index As Long, ByVal fence As Long, ByVal origin As Long, ByVal bound As Long)
				Me.rng = rng
				Me.index = index
				Me.fence = fence
				Me.origin = origin
				Me.bound = bound
			End Sub

			Public Function trySplit() As RandomLongsSpliterator
				Dim i As Long = index, m As Long = CInt(CUInt((i + fence)) >> 1)
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
				Return If(m <= i, Nothing, New RandomLongsSpliterator(rng.Split(), i, index = m, origin, bound))
			End Function

			Public Function estimateSize() As Long
				Return fence - index
			End Function

			Public Function characteristics() As Integer
				Return (Spliterator.SIZED Or Spliterator.SUBSIZED Or Spliterator.NONNULL Or Spliterator.IMMUTABLE)
			End Function

			Public Function tryAdvance(ByVal consumer As java.util.function.LongConsumer) As Boolean
				If consumer Is Nothing Then Throw New NullPointerException
				Dim i As Long = index, f As Long = fence
				If i < f Then
					consumer.accept(rng.internalNextLong(origin, bound))
					index = i + 1
					Return True
				End If
				Return False
			End Function

			Public Sub forEachRemaining(ByVal consumer As java.util.function.LongConsumer)
				If consumer Is Nothing Then Throw New NullPointerException
				Dim i As Long = index, f As Long = fence
				If i < f Then
					index = f
					Dim r As SplittableRandom = rng
					Dim o As Long = origin, b As Long = bound
					Do
						consumer.accept(r.internalNextLong(o, b))
						i += 1
					Loop While i < f
				End If
			End Sub

		End Class

		''' <summary>
		''' Spliterator for double streams.
		''' </summary>
		Friend NotInheritable Class RandomDoublesSpliterator
			Implements Spliterator.OfDouble

			Friend ReadOnly rng As SplittableRandom
			Friend index As Long
			Friend ReadOnly fence As Long
			Friend ReadOnly origin As Double
			Friend ReadOnly bound As Double
			Friend Sub New(ByVal rng As SplittableRandom, ByVal index As Long, ByVal fence As Long, ByVal origin As Double, ByVal bound As Double)
				Me.rng = rng
				Me.index = index
				Me.fence = fence
				Me.origin = origin
				Me.bound = bound
			End Sub

			Public Function trySplit() As RandomDoublesSpliterator
				Dim i As Long = index, m As Long = CInt(CUInt((i + fence)) >> 1)
'JAVA TO VB CONVERTER TODO TASK: Assignments within expressions are not supported in VB
				Return If(m <= i, Nothing, New RandomDoublesSpliterator(rng.Split(), i, index = m, origin, bound))
			End Function

			Public Function estimateSize() As Long
				Return fence - index
			End Function

			Public Function characteristics() As Integer
				Return (Spliterator.SIZED Or Spliterator.SUBSIZED Or Spliterator.NONNULL Or Spliterator.IMMUTABLE)
			End Function

			Public Function tryAdvance(ByVal consumer As java.util.function.DoubleConsumer) As Boolean
				If consumer Is Nothing Then Throw New NullPointerException
				Dim i As Long = index, f As Long = fence
				If i < f Then
					consumer.accept(rng.internalNextDouble(origin, bound))
					index = i + 1
					Return True
				End If
				Return False
			End Function

			Public Sub forEachRemaining(ByVal consumer As java.util.function.DoubleConsumer)
				If consumer Is Nothing Then Throw New NullPointerException
				Dim i As Long = index, f As Long = fence
				If i < f Then
					index = f
					Dim r As SplittableRandom = rng
					Dim o As Double = origin, b As Double = bound
					Do
						consumer.accept(r.internalNextDouble(o, b))
						i += 1
					Loop While i < f
				End If
			End Sub
		End Class

	End Class

End Namespace