Imports System
Imports javax.swing.event
Imports javax.swing.border
Imports javax.accessibility

'
' * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
' * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' *
' 

Namespace javax.swing



	''' <summary>
	''' The "viewport" or "porthole" through which you see the underlying
	''' information. When you scroll, what moves is the viewport. It is like
	''' peering through a camera's viewfinder. Moving the viewfinder upwards
	''' brings new things into view at the top of the picture and loses
	''' things that were at the bottom.
	''' <p>
	''' By default, <code>JViewport</code> is opaque. To change this, use the
	''' <code>setOpaque</code> method.
	''' <p>
	''' <b>NOTE:</b>We have implemented a faster scrolling algorithm that
	''' does not require a buffer to draw in. The algorithm works as follows:
	''' <ol><li>The view and parent view and checked to see if they are
	''' <code>JComponents</code>,
	''' if they aren't, stop and repaint the whole viewport.
	''' <li>If the viewport is obscured by an ancestor, stop and repaint the whole
	''' viewport.
	''' <li>Compute the region that will become visible, if it is as big as
	''' the viewport, stop and repaint the whole view region.
	''' <li>Obtain the ancestor <code>Window</code>'s graphics and
	''' do a <code>copyArea</code> on the scrolled region.
	''' <li>Message the view to repaint the newly visible region.
	''' <li>The next time paint is invoked on the viewport, if the clip region
	''' is smaller than the viewport size a timer is kicked off to repaint the
	''' whole region.
	''' </ol>
	''' In general this approach is much faster. Compared to the backing store
	''' approach this avoids the overhead of maintaining an offscreen buffer and
	''' having to do two <code>copyArea</code>s.
	''' Compared to the non backing store case this
	''' approach will greatly reduce the painted region.
	''' <p>
	''' This approach can cause slower times than the backing store approach
	''' when the viewport is obscured by another window, or partially offscreen.
	''' When another window
	''' obscures the viewport the copyArea will copy garbage and a
	''' paint event will be generated by the system to inform us we need to
	''' paint the newly exposed region. The only way to handle this is to
	''' repaint the whole viewport, which can cause slower performance than the
	''' backing store case. In most applications very rarely will the user be
	''' scrolling while the viewport is obscured by another window or offscreen,
	''' so this optimization is usually worth the performance hit when obscured.
	''' <p>
	''' <strong>Warning:</strong> Swing is not thread safe. For more
	''' information see <a
	''' href="package-summary.html#threading">Swing's Threading
	''' Policy</a>.
	''' <p>
	''' <strong>Warning:</strong>
	''' Serialized objects of this class will not be compatible with
	''' future Swing releases. The current serialization support is
	''' appropriate for short term storage or RMI between applications running
	''' the same version of Swing.  As of 1.4, support for long term storage
	''' of all JavaBeans&trade;
	''' has been added to the <code>java.beans</code> package.
	''' Please see <seealso cref="java.beans.XMLEncoder"/>.
	''' 
	''' @author Hans Muller
	''' @author Philip Milne </summary>
	''' <seealso cref= JScrollPane </seealso>
	Public Class JViewport
		Inherits JComponent
		Implements Accessible

		''' <seealso cref= #getUIClassID </seealso>
		''' <seealso cref= #readObject </seealso>
		Private Const uiClassID As String = "ViewportUI"

		''' <summary>
		''' Property used to indicate window blitting should not be done.
		''' </summary>
		Friend Const EnableWindowBlit As Object = "EnableWindowBlit"

		''' <summary>
		''' True when the viewport dimensions have been determined.
		''' The default is false.
		''' </summary>
		Protected Friend isViewSizeSet As Boolean = False

		''' <summary>
		''' The last <code>viewPosition</code> that we've painted, so we know how
		''' much of the backing store image is valid.
		''' </summary>
		Protected Friend lastPaintPosition As Point = Nothing

		''' <summary>
		''' True when this viewport is maintaining an offscreen image of its
		''' contents, so that some scrolling can take place using fast "bit-blit"
		''' operations instead of by accessing the view object to construct the
		''' display.  The default is <code>false</code>.
		''' </summary>
		''' @deprecated As of Java 2 platform v1.3 
		''' <seealso cref= #setScrollMode </seealso>
		<Obsolete("As of Java 2 platform v1.3")> _
		Protected Friend backingStore As Boolean = False

		''' <summary>
		''' The view image used for a backing store. </summary>
		<NonSerialized> _
		Protected Friend backingStoreImage As Image = Nothing

		''' <summary>
		''' The <code>scrollUnderway</code> flag is used for components like
		''' <code>JList</code>.  When the downarrow key is pressed on a
		''' <code>JList</code> and the selected
		''' cell is the last in the list, the <code>scrollpane</code> autoscrolls.
		''' Here, the old selected cell needs repainting and so we need
		''' a flag to make the viewport do the optimized painting
		''' only when there is an explicit call to
		''' <code>setViewPosition(Point)</code>.
		''' When <code>setBounds</code> is called through other routes,
		''' the flag is off and the view repaints normally.  Another approach
		''' would be to remove this from the <code>JViewport</code>
		''' class and have the <code>JList</code> manage this case by using
		''' <code>setBackingStoreEnabled</code>.  The default is
		''' <code>false</code>.
		''' </summary>
		Protected Friend scrollUnderway As Boolean = False

	'    
	'     * Listener that is notified each time the view changes size.
	'     
		Private viewListener As ComponentListener = Nothing

	'     Only one <code>ChangeEvent</code> is needed per
	'     * <code>JViewport</code> instance since the
	'     * event's only (read-only) state is the source property.  The source
	'     * of events generated here is always "this".
	'     
		<NonSerialized> _
		Private changeEvent As ChangeEvent = Nothing

		''' <summary>
		''' Use <code>graphics.copyArea</code> to implement scrolling.
		''' This is the fastest for most applications.
		''' </summary>
		''' <seealso cref= #setScrollMode
		''' @since 1.3 </seealso>
		Public Const BLIT_SCROLL_MODE As Integer = 1

		''' <summary>
		''' Draws viewport contents into an offscreen image.
		''' This was previously the default mode for <code>JTable</code>.
		''' This mode may offer advantages over "blit mode"
		''' in some cases, but it requires a large chunk of extra RAM.
		''' </summary>
		''' <seealso cref= #setScrollMode
		''' @since 1.3 </seealso>
		Public Const BACKINGSTORE_SCROLL_MODE As Integer = 2

		''' <summary>
		''' This mode uses the very simple method of redrawing the entire
		''' contents of the scrollpane each time it is scrolled.
		''' This was the default behavior in Swing 1.0 and Swing 1.1.
		''' Either of the other two options will provide better performance
		''' in most cases.
		''' </summary>
		''' <seealso cref= #setScrollMode
		''' @since 1.3 </seealso>
		Public Const SIMPLE_SCROLL_MODE As Integer = 0

		''' <seealso cref= #setScrollMode
		''' @since 1.3 </seealso>
		Private scrollMode As Integer = BLIT_SCROLL_MODE

		'
		' Window blitting:
		'
		' As mentioned in the javadoc when using windowBlit a paint event
		' will be generated by the system if copyArea copies a non-visible
		' portion of the view (in other words, it copies garbage). We are
		' not guaranteed to receive the paint event before other mouse events,
		' so we can not be sure we haven't already copied garbage a bunch of
		' times to different parts of the view. For that reason when a blit
		' happens and the Component is obscured (the check for obscurity
		' is not supported on all platforms and is checked via ComponentPeer
		' methods) the ivar repaintAll is set to true. When paint is received
		' if repaintAll is true (we previously did a blit) it is set to
		' false, and if the clip region is smaller than the viewport
		' waitingForRepaint is set to true and a timer is started. When
		' the timer fires if waitingForRepaint is true, repaint is invoked.
		' In the mean time, if the view is asked to scroll and waitingForRepaint
		' is true, a blit will not happen, instead the non-backing store case
		' of scrolling will happen, which will reset waitingForRepaint.
		' waitingForRepaint is set to false in paint when the clip rect is
		' bigger (or equal) to the size of the viewport.
		' A Timer is used instead of just a repaint as it appeared to offer
		' better performance.


		''' <summary>
		''' This is set to true in <code>setViewPosition</code>
		''' if doing a window blit and the viewport is obscured.
		''' </summary>
		<NonSerialized> _
		Private repaintAll As Boolean

		''' <summary>
		''' This is set to true in paint, if <code>repaintAll</code>
		''' is true and the clip rectangle does not match the bounds.
		''' If true, and scrolling happens the
		''' repaint manager is not cleared which then allows for the repaint
		''' previously invoked to succeed.
		''' </summary>
		<NonSerialized> _
		Private waitingForRepaint As Boolean

		''' <summary>
		''' Instead of directly invoking repaint, a <code>Timer</code>
		''' is started and when it fires, repaint is invoked.
		''' </summary>
		<NonSerialized> _
		Private repaintTimer As Timer

		''' <summary>
		''' Set to true in paintView when paint is invoked.
		''' </summary>
		<NonSerialized> _
		Private inBlitPaint As Boolean

		''' <summary>
		''' Whether or not a valid view has been installed.
		''' </summary>
		Private hasHadValidView As Boolean

		''' <summary>
		''' When view is changed we have to synchronize scrollbar values
		''' with viewport (see the BasicScrollPaneUI#syncScrollPaneWithViewport method).
		''' This flag allows to invoke that method while ScrollPaneLayout#layoutContainer
		''' is running.
		''' </summary>
		Private viewChanged As Boolean

		''' <summary>
		''' Creates a <code>JViewport</code>. </summary>
		Public Sub New()
			MyBase.New()
			layout = createLayoutManager()
			opaque = True
			updateUI()
			inheritsPopupMenu = True
		End Sub



		''' <summary>
		''' Returns the L&amp;F object that renders this component.
		''' </summary>
		''' <returns> a <code>ViewportUI</code> object
		''' @since 1.3 </returns>
		Public Overridable Property uI As javax.swing.plaf.ViewportUI
			Get
				Return CType(ui, javax.swing.plaf.ViewportUI)
			End Get
			Set(ByVal ui As javax.swing.plaf.ViewportUI)
				MyBase.uI = ui
			End Set
		End Property




		''' <summary>
		''' Resets the UI property to a value from the current look and feel.
		''' </summary>
		''' <seealso cref= JComponent#updateUI </seealso>
		Public Overrides Sub updateUI()
			uI = CType(UIManager.getUI(Me), javax.swing.plaf.ViewportUI)
		End Sub


		''' <summary>
		''' Returns a string that specifies the name of the L&amp;F class
		''' that renders this component.
		''' </summary>
		''' <returns> the string "ViewportUI"
		''' </returns>
		''' <seealso cref= JComponent#getUIClassID </seealso>
		''' <seealso cref= UIDefaults#getUI </seealso>
		Public Property Overrides uIClassID As String
			Get
				Return uiClassID
			End Get
		End Property


		''' <summary>
		''' Sets the <code>JViewport</code>'s one lightweight child,
		''' which can be <code>null</code>.
		''' (Since there is only one child which occupies the entire viewport,
		''' the <code>constraints</code> and <code>index</code>
		''' arguments are ignored.)
		''' </summary>
		''' <param name="child">       the lightweight <code>child</code> of the viewport </param>
		''' <param name="constraints"> the <code>constraints</code> to be respected </param>
		''' <param name="index">       the index </param>
		''' <seealso cref= #setView </seealso>
		Protected Friend Overridable Sub addImpl(ByVal child As Component, ByVal constraints As Object, ByVal index As Integer)
		  view = child
		End Sub


		''' <summary>
		''' Removes the <code>Viewport</code>s one lightweight child.
		''' </summary>
		''' <seealso cref= #setView </seealso>
		Public Overridable Sub remove(ByVal child As Component)
			child.removeComponentListener(viewListener)
			MyBase.remove(child)
		End Sub

		''' <summary>
		''' Scrolls the view so that <code>Rectangle</code>
		''' within the view becomes visible.
		''' <p>
		''' This attempts to validate the view before scrolling if the
		''' view is currently not valid - <code>isValid</code> returns false.
		''' To avoid excessive validation when the containment hierarchy is
		''' being created this will not validate if one of the ancestors does not
		''' have a peer, or there is no validate root ancestor, or one of the
		''' ancestors is not a <code>Window</code> or <code>Applet</code>.
		''' <p>
		''' Note that this method will not scroll outside of the
		''' valid viewport; for example, if <code>contentRect</code> is larger
		''' than the viewport, scrolling will be confined to the viewport's
		''' bounds.
		''' </summary>
		''' <param name="contentRect"> the <code>Rectangle</code> to display </param>
		''' <seealso cref= JComponent#isValidateRoot </seealso>
		''' <seealso cref= java.awt.Component#isValid </seealso>
		''' <seealso cref= java.awt.Component#getPeer </seealso>
		Public Overrides Sub scrollRectToVisible(ByVal contentRect As Rectangle)
			Dim ___view As Component = view

			If ___view Is Nothing Then
				Return
			Else
				If Not ___view.valid Then validateView()
				Dim dx, dy As Integer

				dx = positionAdjustment(width, contentRect.width, contentRect.x)
				dy = positionAdjustment(height, contentRect.height, contentRect.y)

				If dx <> 0 OrElse dy <> 0 Then
					Dim ___viewPosition As Point = viewPosition
					Dim ___viewSize As Dimension = ___view.size
					Dim startX As Integer = ___viewPosition.x
					Dim startY As Integer = ___viewPosition.y
					Dim extent As Dimension = extentSize

					___viewPosition.x -= dx
					___viewPosition.y -= dy
					' Only constrain the location if the view is valid. If the
					' the view isn't valid, it typically indicates the view
					' isn't visible yet and most likely has a bogus size as will
					' we, and therefore we shouldn't constrain the scrolling
					If ___view.valid Then
						If parent.componentOrientation.leftToRight Then
							If ___viewPosition.x + extent.width > ___viewSize.width Then
								___viewPosition.x = Math.Max(0, ___viewSize.width - extent.width)
							ElseIf ___viewPosition.x < 0 Then
								___viewPosition.x = 0
							End If
						Else
							If extent.width > ___viewSize.width Then
								___viewPosition.x = ___viewSize.width - extent.width
							Else
								___viewPosition.x = Math.Max(0, Math.Min(___viewSize.width - extent.width, ___viewPosition.x))
							End If
						End If
						If ___viewPosition.y + extent.height > ___viewSize.height Then
							___viewPosition.y = Math.Max(0, ___viewSize.height - extent.height)
						ElseIf ___viewPosition.y < 0 Then
							___viewPosition.y = 0
						End If
					End If
					If ___viewPosition.x <> startX OrElse ___viewPosition.y <> startY Then
						viewPosition = ___viewPosition
						' NOTE: How JViewport currently works with the
						' backing store is not foolproof. The sequence of
						' events when setViewPosition
						' (scrollRectToVisible) is called is to reset the
						' views bounds, which causes a repaint on the
						' visible region and sets an ivar indicating
						' scrolling (scrollUnderway). When
						' JViewport.paint is invoked if scrollUnderway is
						' true, the backing store is blitted.  This fails
						' if between the time setViewPosition is invoked
						' and paint is received another repaint is queued
						' indicating part of the view is invalid. There
						' is no way for JViewport to notice another
						' repaint has occurred and it ends up blitting
						' what is now a dirty region and the repaint is
						' never delivered.
						' It just so happens JTable encounters this
						' behavior by way of scrollRectToVisible, for
						' this reason scrollUnderway is set to false
						' here, which effectively disables the backing
						' store.
						scrollUnderway = False
					End If
				End If
			End If
		End Sub

		''' <summary>
		''' Ascends the <code>Viewport</code>'s parents stopping when
		''' a component is found that returns
		''' <code>true</code> to <code>isValidateRoot</code>.
		''' If all the <code>Component</code>'s  parents are visible,
		''' <code>validate</code> will then be invoked on it. The
		''' <code>RepaintManager</code> is then invoked with
		''' <code>removeInvalidComponent</code>. This
		''' is the synchronous version of a <code>revalidate</code>.
		''' </summary>
		Private Sub validateView()
			Dim ___validateRoot As Component = SwingUtilities.getValidateRoot(Me, False)

			If ___validateRoot Is Nothing Then Return

			' Validate the root.
			___validateRoot.validate()

			' And let the RepaintManager it does not have to validate from
			' validateRoot anymore.
			Dim rm As RepaintManager = RepaintManager.currentManager(Me)

			If rm IsNot Nothing Then rm.removeInvalidComponent(CType(___validateRoot, JComponent))
		End Sub

	'       Used by the scrollRectToVisible method to determine the
	'      *  proper direction and amount to move by. The integer variables are named
	'      *  width, but this method is applicable to height also. The code assumes that
	'      *  parentWidth/childWidth are positive and childAt can be negative.
	'      
		Private Function positionAdjustment(ByVal parentWidth As Integer, ByVal childWidth As Integer, ByVal childAt As Integer) As Integer

			'   +-----+
			'   | --- |     No Change
			'   +-----+
			If childAt >= 0 AndAlso childWidth + childAt <= parentWidth Then Return 0

			'   +-----+
			'  ---------   No Change
			'   +-----+
			If childAt <= 0 AndAlso childWidth + childAt >= parentWidth Then Return 0

			'   +-----+          +-----+
			'   |   ----    ->   | ----|
			'   +-----+          +-----+
			If childAt > 0 AndAlso childWidth <= parentWidth Then Return -childAt + parentWidth - childWidth

			'   +-----+             +-----+
			'   |  --------  ->     |--------
			'   +-----+             +-----+
			If childAt >= 0 AndAlso childWidth >= parentWidth Then Return -childAt

			'   +-----+          +-----+
			' ----    |     ->   |---- |
			'   +-----+          +-----+
			If childAt <= 0 AndAlso childWidth <= parentWidth Then Return -childAt

			'   +-----+             +-----+
			'-------- |      ->   --------|
			'   +-----+             +-----+
			If childAt < 0 AndAlso childWidth >= parentWidth Then Return -childAt + parentWidth - childWidth

			Return 0
		End Function


		''' <summary>
		''' The viewport "scrolls" its child (called the "view") by the
		''' normal parent/child clipping (typically the view is moved in
		''' the opposite direction of the scroll).  A non-<code>null</code> border,
		''' or non-zero insets, isn't supported, to prevent the geometry
		''' of this component from becoming complex enough to inhibit
		''' subclassing.  To create a <code>JViewport</code> with a border,
		''' add it to a <code>JPanel</code> that has a border.
		''' <p>Note:  If <code>border</code> is non-<code>null</code>, this
		''' method will throw an exception as borders are not supported on
		''' a <code>JViewPort</code>.
		''' </summary>
		''' <param name="border"> the <code>Border</code> to set </param>
		''' <exception cref="IllegalArgumentException"> this method is not implemented </exception>
		Public NotOverridable Overrides Property border As Border
			Set(ByVal border As Border)
				If border IsNot Nothing Then Throw New System.ArgumentException("JViewport.setBorder() not supported")
			End Set
		End Property


		''' <summary>
		''' Returns the insets (border) dimensions as (0,0,0,0), since borders
		''' are not supported on a <code>JViewport</code>.
		''' </summary>
		''' <returns> a <code>Rectangle</code> of zero dimension and zero origin </returns>
		''' <seealso cref= #setBorder </seealso>
		Public Property NotOverridable Overrides insets As Insets
			Get
				Return New Insets(0, 0, 0, 0)
			End Get
		End Property

		''' <summary>
		''' Returns an <code>Insets</code> object containing this
		''' <code>JViewport</code>s inset values.  The passed-in
		''' <code>Insets</code> object will be reinitialized, and
		''' all existing values within this object are overwritten.
		''' </summary>
		''' <param name="insets"> the <code>Insets</code> object which can be reused </param>
		''' <returns> this viewports inset values </returns>
		''' <seealso cref= #getInsets
		''' @beaninfo
		'''   expert: true </seealso>
		Public NotOverridable Overrides Function getInsets(ByVal insets As Insets) As Insets
				insets.bottom = 0
					insets.right = insets.bottom
						insets.top = insets.right
						insets.left = insets.top
			Return insets
		End Function


		Private Function getBackingStoreGraphics(ByVal g As Graphics) As Graphics
			Dim bsg As Graphics = backingStoreImage.graphics
			bsg.color = g.color
			bsg.font = g.font
			bsg.clip = g.clipBounds
			Return bsg
		End Function


		Private Sub paintViaBackingStore(ByVal g As Graphics)
			Dim bsg As Graphics = getBackingStoreGraphics(g)
			Try
				MyBase.paint(bsg)
				g.drawImage(backingStoreImage, 0, 0, Me)
			Finally
				bsg.Dispose()
			End Try
		End Sub

		Private Sub paintViaBackingStore(ByVal g As Graphics, ByVal oClip As Rectangle)
			Dim bsg As Graphics = getBackingStoreGraphics(g)
			Try
				MyBase.paint(bsg)
				g.clip = oClip
				g.drawImage(backingStoreImage, 0, 0, Me)
			Finally
				bsg.Dispose()
			End Try
		End Sub

		''' <summary>
		''' The <code>JViewport</code> overrides the default implementation of
		''' this method (in <code>JComponent</code>) to return false.
		''' This ensures
		''' that the drawing machinery will call the <code>Viewport</code>'s
		''' <code>paint</code>
		''' implementation rather than messaging the <code>JViewport</code>'s
		''' children directly.
		''' </summary>
		''' <returns> false </returns>
		Public Property Overrides optimizedDrawingEnabled As Boolean
			Get
				Return False
			End Get
		End Property

		''' <summary>
		''' Returns true if scroll mode is a {@code BACKINGSTORE_SCROLL_MODE} to cause
		''' painting to originate from {@code JViewport}, or one of its
		''' ancestors. Otherwise returns {@code false}.
		''' </summary>
		''' <returns> true if if scroll mode is a {@code BACKINGSTORE_SCROLL_MODE}. </returns>
		''' <seealso cref= JComponent#isPaintingOrigin() </seealso>
		Protected Friend Property Overrides paintingOrigin As Boolean
			Get
				Return scrollMode = BACKINGSTORE_SCROLL_MODE
			End Get
		End Property


		''' <summary>
		''' Only used by the paint method below.
		''' </summary>
		Private Property viewLocation As Point
			Get
				Dim ___view As Component = view
				If ___view IsNot Nothing Then
					Return ___view.location
				Else
					Return New Point(0,0)
				End If
			End Get
		End Property

		''' <summary>
		''' Depending on whether the <code>backingStore</code> is enabled,
		''' either paint the image through the backing store or paint
		''' just the recently exposed part, using the backing store
		''' to "blit" the remainder.
		''' <blockquote>
		''' The term "blit" is the pronounced version of the PDP-10
		''' BLT (BLock Transfer) instruction, which copied a block of
		''' bits. (In case you were curious.)
		''' </blockquote>
		''' </summary>
		''' <param name="g"> the <code>Graphics</code> context within which to paint </param>
		Public Overrides Sub paint(ByVal g As Graphics)
			Dim ___width As Integer = width
			Dim ___height As Integer = height

			If (___width <= 0) OrElse (___height <= 0) Then Return

			If inBlitPaint Then
				' We invoked paint as part of copyArea cleanup, let it through.
				MyBase.paint(g)
				Return
			End If

			If repaintAll Then
				repaintAll = False
				Dim clipB As Rectangle = g.clipBounds
				If clipB.width < width OrElse clipB.height < height Then
					waitingForRepaint = True
					If repaintTimer Is Nothing Then repaintTimer = createRepaintTimer()
					repaintTimer.stop()
					repaintTimer.start()
					' We really don't need to paint, a future repaint will
					' take care of it, but if we don't we get an ugly flicker.
				Else
					If repaintTimer IsNot Nothing Then repaintTimer.stop()
					waitingForRepaint = False
				End If
			ElseIf waitingForRepaint Then
				' Need a complete repaint before resetting waitingForRepaint
				Dim clipB As Rectangle = g.clipBounds
				If clipB.width >= width AndAlso clipB.height >= height Then
					waitingForRepaint = False
					repaintTimer.stop()
				End If
			End If

			If (Not backingStore) OrElse blitting OrElse view Is Nothing Then
				MyBase.paint(g)
				lastPaintPosition = viewLocation
				Return
			End If

			' If the view is smaller than the viewport and we are not opaque
			' (that is, we won't paint our background), we should set the
			' clip. Otherwise, as the bounds of the view vary, we will
			' blit garbage into the exposed areas.
			Dim viewBounds As Rectangle = view.bounds
			If Not opaque Then g.clipRect(0, 0, viewBounds.width, viewBounds.height)

			If backingStoreImage Is Nothing Then
				' Backing store is enabled but this is the first call to paint.
				' Create the backing store, paint it and then copy to g.
				' The backing store image will be created with the size of
				' the viewport. We must make sure the clip region is the
				' same size, otherwise when scrolling the backing image
				' the region outside of the clipped region will not be painted,
				' and result in empty areas.
				backingStoreImage = createImage(___width, ___height)
				Dim clip As Rectangle = g.clipBounds
				If clip.width <> ___width OrElse clip.height <> ___height Then
					If Not opaque Then
						g.cliplip(0, 0, Math.Min(viewBounds.width, ___width), Math.Min(viewBounds.height, ___height))
					Else
						g.cliplip(0, 0, ___width, ___height)
					End If
					paintViaBackingStore(g, clip)
				Else
					paintViaBackingStore(g)
				End If
			Else
				If (Not scrollUnderway) OrElse lastPaintPosition.Equals(viewLocation) Then
					' No scrolling happened: repaint required area via backing store.
					paintViaBackingStore(g)
				Else
					' The image was scrolled. Manipulate the backing store and flush it to g.
					Dim blitFrom As New Point
					Dim blitTo As New Point
					Dim blitSize As New Dimension
					Dim blitPaint As New Rectangle

					Dim newLocation As Point = viewLocation
					Dim dx As Integer = newLocation.x - lastPaintPosition.x
					Dim dy As Integer = newLocation.y - lastPaintPosition.y
					Dim canBlit As Boolean = computeBlit(dx, dy, blitFrom, blitTo, blitSize, blitPaint)
					If Not canBlit Then
						' The image was either moved diagonally or
						' moved by more than the image size: paint normally.
						paintViaBackingStore(g)
					Else
						Dim bdx As Integer = blitTo.x - blitFrom.x
						Dim bdy As Integer = blitTo.y - blitFrom.y

						' Move the relevant part of the backing store.
						Dim clip As Rectangle = g.clipBounds
						' We don't want to inherit the clip region when copying
						' bits, if it is inherited it will result in not moving
						' all of the image resulting in garbage appearing on
						' the screen.
						g.cliplip(0, 0, ___width, ___height)
						Dim bsg As Graphics = getBackingStoreGraphics(g)
						Try
							bsg.copyArea(blitFrom.x, blitFrom.y, blitSize.width, blitSize.height, bdx, bdy)

							g.cliplip(clip.x, clip.y, clip.width, clip.height)
							' Paint the rest of the view; the part that has just been exposed.
							Dim r As Rectangle = viewBounds.intersection(blitPaint)
							bsg.clip = r
							MyBase.paint(bsg)

							' Copy whole of the backing store to g.
							g.drawImage(backingStoreImage, 0, 0, Me)
						Finally
							bsg.Dispose()
						End Try
					End If
				End If
			End If
			lastPaintPosition = viewLocation
			scrollUnderway = False
		End Sub


		''' <summary>
		''' Sets the bounds of this viewport.  If the viewport's width
		''' or height has changed, fire a <code>StateChanged</code> event.
		''' </summary>
		''' <param name="x"> left edge of the origin </param>
		''' <param name="y"> top edge of the origin </param>
		''' <param name="w"> width in pixels </param>
		''' <param name="h"> height in pixels
		''' </param>
		''' <seealso cref= JComponent#reshape(int, int, int, int) </seealso>
		Public Overrides Sub reshape(ByVal x As Integer, ByVal y As Integer, ByVal w As Integer, ByVal h As Integer)
			Dim sizeChanged As Boolean = (width <> w) OrElse (height <> h)
			If sizeChanged Then backingStoreImage = Nothing
			MyBase.reshape(x, y, w, h)
			If sizeChanged OrElse viewChanged Then
				viewChanged = False

				fireStateChanged()
			End If
		End Sub


		''' <summary>
		''' Used to control the method of scrolling the viewport contents.
		''' You may want to change this mode to get maximum performance for your
		''' use case.
		''' </summary>
		''' <param name="mode"> one of the following values:
		''' <ul>
		''' <li> JViewport.BLIT_SCROLL_MODE
		''' <li> JViewport.BACKINGSTORE_SCROLL_MODE
		''' <li> JViewport.SIMPLE_SCROLL_MODE
		''' </ul>
		''' </param>
		''' <seealso cref= #BLIT_SCROLL_MODE </seealso>
		''' <seealso cref= #BACKINGSTORE_SCROLL_MODE </seealso>
		''' <seealso cref= #SIMPLE_SCROLL_MODE
		'''  
		''' @beaninfo
		'''        bound: false
		'''  description: Method of moving contents for incremental scrolls.
		'''         enum: BLIT_SCROLL_MODE JViewport.BLIT_SCROLL_MODE
		'''               BACKINGSTORE_SCROLL_MODE JViewport.BACKINGSTORE_SCROLL_MODE
		'''               SIMPLE_SCROLL_MODE JViewport.SIMPLE_SCROLL_MODE
		'''  
		''' @since 1.3 </seealso>
		Public Overridable Property scrollMode As Integer
			Set(ByVal mode As Integer)
				scrollMode = mode
				backingStore = mode = BACKINGSTORE_SCROLL_MODE
			End Set
			Get
				Return scrollMode
			End Get
		End Property


		''' <summary>
		''' Returns <code>true</code> if this viewport is maintaining
		''' an offscreen image of its contents.
		''' </summary>
		''' <returns> <code>true</code> if <code>scrollMode</code> is
		'''    <code>BACKINGSTORE_SCROLL_MODE</code>
		''' </returns>
		''' @deprecated As of Java 2 platform v1.3, replaced by
		'''             <code>getScrollMode()</code>. 
		<Obsolete("As of Java 2 platform v1.3, replaced by")> _
		Public Overridable Property backingStoreEnabled As Boolean
			Get
				Return scrollMode = BACKINGSTORE_SCROLL_MODE
			End Get
			Set(ByVal enabled As Boolean)
				If enabled Then
					scrollMode = BACKINGSTORE_SCROLL_MODE
				Else
					scrollMode = BLIT_SCROLL_MODE
				End If
			End Set
		End Property



		Private Property blitting As Boolean
			Get
				Dim ___view As Component = view
				Return (scrollMode = BLIT_SCROLL_MODE) AndAlso (TypeOf ___view Is JComponent) AndAlso ___view.opaque
			End Get
		End Property


		''' <summary>
		''' Returns the <code>JViewport</code>'s one child or <code>null</code>.
		''' </summary>
		''' <returns> the viewports child, or <code>null</code> if none exists
		''' </returns>
		''' <seealso cref= #setView </seealso>
		Public Overridable Property view As Component
			Get
				Return If(componentCount > 0, getComponent(0), Nothing)
			End Get
			Set(ByVal view As Component)
    
		'         Remove the viewport's existing children, if any.
		'         * Note that removeAll() isn't used here because it
		'         * doesn't call remove() (which JViewport overrides).
		'         
				Dim n As Integer = componentCount
				For i As Integer = n - 1 To 0 Step -1
					remove(getComponent(i))
				Next i
    
				isViewSizeSet = False
    
				If view IsNot Nothing Then
					MyBase.addImpl(view, Nothing, -1)
					viewListener = createViewListener()
					view.addComponentListener(viewListener)
				End If
    
				If hasHadValidView Then
					' Only fire a change if a view has been installed.
					fireStateChanged()
				ElseIf view IsNot Nothing Then
					hasHadValidView = True
				End If
    
				viewChanged = True
    
				revalidate()
				repaint()
			End Set
		End Property



		''' <summary>
		''' If the view's size hasn't been explicitly set, return the
		''' preferred size, otherwise return the view's current size.
		''' If there is no view, return 0,0.
		''' </summary>
		''' <returns> a <code>Dimension</code> object specifying the size of the view </returns>
		Public Overridable Property viewSize As Dimension
			Get
				Dim ___view As Component = view
    
				If ___view Is Nothing Then
					Return New Dimension(0,0)
				ElseIf isViewSizeSet Then
					Return ___view.size
				Else
					Return ___view.preferredSize
				End If
			End Get
			Set(ByVal newSize As Dimension)
				Dim ___view As Component = view
				If ___view IsNot Nothing Then
					Dim oldSize As Dimension = ___view.size
					If Not newSize.Equals(oldSize) Then
						' scrollUnderway will be true if this is invoked as the
						' result of a validate and setViewPosition was previously
						' invoked.
						scrollUnderway = False
						___view.size = newSize
						isViewSizeSet = True
						fireStateChanged()
					End If
				End If
			End Set
		End Property



		''' <summary>
		''' Returns the view coordinates that appear in the upper left
		''' hand corner of the viewport, or 0,0 if there's no view.
		''' </summary>
		''' <returns> a <code>Point</code> object giving the upper left coordinates </returns>
		Public Overridable Property viewPosition As Point
			Get
				Dim ___view As Component = view
				If ___view IsNot Nothing Then
					Dim p As Point = ___view.location
					p.x = -p.x
					p.y = -p.y
					Return p
				Else
					Return New Point(0,0)
				End If
			End Get
			Set(ByVal p As Point)
				Dim ___view As Component = view
				If ___view Is Nothing Then Return
    
				Dim oldX As Integer, oldY As Integer, ___x As Integer = p.x, ___y As Integer = p.y
    
		'         Collect the old x,y values for the views location
		'         * and do the song and dance to avoid allocating
		'         * a Rectangle object if we don't have to.
		'         
				If TypeOf ___view Is JComponent Then
					Dim c As JComponent = CType(___view, JComponent)
					oldX = c.x
					oldY = c.y
				Else
					Dim r As Rectangle = ___view.bounds
					oldX = r.x
					oldY = r.y
				End If
    
		'         The view scrolls in the opposite direction to mouse
		'         * movement.
		'         
				Dim newX As Integer = -___x
				Dim newY As Integer = -___y
    
				If (oldX <> newX) OrElse (oldY <> newY) Then
					If (Not waitingForRepaint) AndAlso blitting AndAlso canUseWindowBlitter() Then
						Dim rm As RepaintManager = RepaintManager.currentManager(Me)
						' The cast to JComponent will work, if view is not
						' a JComponent, isBlitting will return false.
						Dim jview As JComponent = CType(___view, JComponent)
						Dim dirty As Rectangle = rm.getDirtyRegion(jview)
						If dirty Is Nothing OrElse (Not dirty.contains(jview.visibleRect)) Then
							rm.beginPaint()
							Try
								Dim g As Graphics = JComponent.safelyGetGraphics(Me)
								flushViewDirtyRegion(g, dirty)
								___view.locationion(newX, newY)
								Dim r As New Rectangle(0, 0, width, Math.Min(height, jview.height))
								g.clip = r
								' Repaint the complete component if the blit succeeded
								' and needsRepaintAfterBlit returns true.
								repaintAll = (windowBlitPaint(g) AndAlso needsRepaintAfterBlit())
								g.Dispose()
								rm.notifyRepaintPerformed(Me, r.x, r.y, r.width, r.height)
								rm.markCompletelyClean(CType(parent, JComponent))
								rm.markCompletelyClean(Me)
								rm.markCompletelyClean(jview)
							Finally
								rm.endPaint()
							End Try
						Else
							' The visible region is dirty, no point in doing copyArea
							___view.locationion(newX, newY)
							repaintAll = False
						End If
					Else
						scrollUnderway = True
						' This calls setBounds(), and then repaint().
						___view.locationion(newX, newY)
						repaintAll = False
					End If
					' we must validate the hierarchy to not break the hw/lw mixing
					revalidate()
					fireStateChanged()
				End If
			End Set
		End Property




		''' <summary>
		''' Returns a rectangle whose origin is <code>getViewPosition</code>
		''' and size is <code>getExtentSize</code>.
		''' This is the visible part of the view, in view coordinates.
		''' </summary>
		''' <returns> a <code>Rectangle</code> giving the visible part of
		'''          the view using view coordinates. </returns>
		Public Overridable Property viewRect As Rectangle
			Get
				Return New Rectangle(viewPosition, extentSize)
			End Get
		End Property


		''' <summary>
		''' Computes the parameters for a blit where the backing store image
		''' currently contains <code>oldLoc</code> in the upper left hand corner
		''' and we're scrolling to <code>newLoc</code>.
		''' The parameters are modified
		''' to return the values required for the blit.
		''' </summary>
		''' <param name="dx">  the horizontal delta </param>
		''' <param name="dy">  the vertical delta </param>
		''' <param name="blitFrom"> the <code>Point</code> we're blitting from </param>
		''' <param name="blitTo"> the <code>Point</code> we're blitting to </param>
		''' <param name="blitSize"> the <code>Dimension</code> of the area to blit </param>
		''' <param name="blitPaint"> the area to blit </param>
		''' <returns>  true if the parameters are modified and we're ready to blit;
		'''          false otherwise </returns>
		Protected Friend Overridable Function computeBlit(ByVal dx As Integer, ByVal dy As Integer, ByVal blitFrom As Point, ByVal blitTo As Point, ByVal blitSize As Dimension, ByVal blitPaint As Rectangle) As Boolean
			Dim dxAbs As Integer = Math.Abs(dx)
			Dim dyAbs As Integer = Math.Abs(dy)
			Dim ___extentSize As Dimension = extentSize

			If (dx = 0) AndAlso (dy <> 0) AndAlso (dyAbs < ___extentSize.height) Then
				If dy < 0 Then
					blitFrom.y = -dy
					blitTo.y = 0
					blitPaint.y = ___extentSize.height + dy
				Else
					blitFrom.y = 0
					blitTo.y = dy
					blitPaint.y = 0
				End If

					blitTo.x = 0
						blitFrom.x = blitTo.x
						blitPaint.x = blitFrom.x

				blitSize.width = ___extentSize.width
				blitSize.height = ___extentSize.height - dyAbs

				blitPaint.width = ___extentSize.width
				blitPaint.height = dyAbs

				Return True

			ElseIf (dy = 0) AndAlso (dx <> 0) AndAlso (dxAbs < ___extentSize.width) Then
				If dx < 0 Then
					blitFrom.x = -dx
					blitTo.x = 0
					blitPaint.x = ___extentSize.width + dx
				Else
					blitFrom.x = 0
					blitTo.x = dx
					blitPaint.x = 0
				End If

					blitTo.y = 0
						blitFrom.y = blitTo.y
						blitPaint.y = blitFrom.y

				blitSize.width = ___extentSize.width - dxAbs
				blitSize.height = ___extentSize.height

				blitPaint.width = dxAbs
				blitPaint.height = ___extentSize.height

				Return True

			Else
				Return False
			End If
		End Function


		''' <summary>
		''' Returns the size of the visible part of the view in view coordinates.
		''' </summary>
		''' <returns> a <code>Dimension</code> object giving the size of the view </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
		Public Overridable Property extentSize As Dimension
			Get
				Return size
			End Get
			Set(ByVal newExtent As Dimension)
				Dim oldExtent As Dimension = extentSize
				If Not newExtent.Equals(oldExtent) Then
					size = newExtent
					fireStateChanged()
				End If
			End Set
		End Property


		''' <summary>
		''' Converts a size in pixel coordinates to view coordinates.
		''' Subclasses of viewport that support "logical coordinates"
		''' will override this method.
		''' </summary>
		''' <param name="size">  a <code>Dimension</code> object using pixel coordinates </param>
		''' <returns> a <code>Dimension</code> object converted to view coordinates </returns>
		Public Overridable Function toViewCoordinates(ByVal size As Dimension) As Dimension
			Return New Dimension(size)
		End Function

		''' <summary>
		''' Converts a point in pixel coordinates to view coordinates.
		''' Subclasses of viewport that support "logical coordinates"
		''' will override this method.
		''' </summary>
		''' <param name="p">  a <code>Point</code> object using pixel coordinates </param>
		''' <returns> a <code>Point</code> object converted to view coordinates </returns>
		Public Overridable Function toViewCoordinates(ByVal p As Point) As Point
			Return New Point(p)
		End Function



		''' <summary>
		''' A listener for the view.
		''' <p>
		''' <strong>Warning:</strong>
		''' Serialized objects of this class will not be compatible with
		''' future Swing releases. The current serialization support is
		''' appropriate for short term storage or RMI between applications running
		''' the same version of Swing.  As of 1.4, support for long term storage
		''' of all JavaBeans&trade;
		''' has been added to the <code>java.beans</code> package.
		''' Please see <seealso cref="java.beans.XMLEncoder"/>.
		''' </summary>
		<Serializable> _
		Protected Friend Class ViewListener
			Inherits ComponentAdapter

			Private ReadOnly outerInstance As JViewport

			Public Sub New(ByVal outerInstance As JViewport)
				Me.outerInstance = outerInstance
			End Sub

			Public Overridable Sub componentResized(ByVal e As ComponentEvent)
				outerInstance.fireStateChanged()
				outerInstance.revalidate()
			End Sub
		End Class

		''' <summary>
		''' Creates a listener for the view. </summary>
		''' <returns> a <code>ViewListener</code> </returns>
		Protected Friend Overridable Function createViewListener() As ViewListener
			Return New ViewListener(Me)
		End Function


		''' <summary>
		''' Subclassers can override this to install a different
		''' layout manager (or <code>null</code>) in the constructor.  Returns
		''' the <code>LayoutManager</code> to install on the <code>JViewport</code>.
		''' </summary>
		''' <returns> a <code>LayoutManager</code> </returns>
		Protected Friend Overridable Function createLayoutManager() As LayoutManager
			Return ViewportLayout.SHARED_INSTANCE
		End Function


		''' <summary>
		''' Adds a <code>ChangeListener</code> to the list that is
		''' notified each time the view's
		''' size, position, or the viewport's extent size has changed.
		''' </summary>
		''' <param name="l"> the <code>ChangeListener</code> to add </param>
		''' <seealso cref= #removeChangeListener </seealso>
		''' <seealso cref= #setViewPosition </seealso>
		''' <seealso cref= #setViewSize </seealso>
		''' <seealso cref= #setExtentSize </seealso>
		Public Overridable Sub addChangeListener(ByVal l As ChangeListener)
			listenerList.add(GetType(ChangeListener), l)
		End Sub

		''' <summary>
		''' Removes a <code>ChangeListener</code> from the list that's notified each
		''' time the views size, position, or the viewports extent size
		''' has changed.
		''' </summary>
		''' <param name="l"> the <code>ChangeListener</code> to remove </param>
		''' <seealso cref= #addChangeListener </seealso>
		Public Overridable Sub removeChangeListener(ByVal l As ChangeListener)
			listenerList.remove(GetType(ChangeListener), l)
		End Sub

		''' <summary>
		''' Returns an array of all the <code>ChangeListener</code>s added
		''' to this JViewport with addChangeListener().
		''' </summary>
		''' <returns> all of the <code>ChangeListener</code>s added or an empty
		'''         array if no listeners have been added
		''' @since 1.4 </returns>
		Public Overridable Property changeListeners As ChangeListener()
			Get
				Return listenerList.getListeners(GetType(ChangeListener))
			End Get
		End Property

		''' <summary>
		''' Notifies all <code>ChangeListeners</code> when the views
		''' size, position, or the viewports extent size has changed.
		''' </summary>
		''' <seealso cref= #addChangeListener </seealso>
		''' <seealso cref= #removeChangeListener </seealso>
		''' <seealso cref= EventListenerList </seealso>
		Protected Friend Overridable Sub fireStateChanged()
			Dim ___listeners As Object() = listenerList.listenerList
			For i As Integer = ___listeners.Length - 2 To 0 Step -2
				If ___listeners(i) Is GetType(ChangeListener) Then
					If changeEvent Is Nothing Then changeEvent = New ChangeEvent(Me)
					CType(___listeners(i + 1), ChangeListener).stateChanged(changeEvent)
				End If
			Next i
		End Sub

		''' <summary>
		''' Always repaint in the parents coordinate system to make sure
		''' only one paint is performed by the <code>RepaintManager</code>.
		''' </summary>
		''' <param name="tm">   maximum time in milliseconds before update </param>
		''' <param name="x">    the <code>x</code> coordinate (pixels over from left) </param>
		''' <param name="y">    the <code>y</code> coordinate (pixels down from top) </param>
		''' <param name="w">    the width </param>
		''' <param name="h">   the height </param>
		''' <seealso cref=       java.awt.Component#update(java.awt.Graphics) </seealso>
		Public Overrides Sub repaint(ByVal tm As Long, ByVal x As Integer, ByVal y As Integer, ByVal w As Integer, ByVal h As Integer)
			Dim parent As Container = parent
			If parent IsNot Nothing Then
				parent.repaint(tm,x+x,y+y,w,h)
			Else
				MyBase.repaint(tm,x,y,w,h)
			End If
		End Sub


		''' <summary>
		''' Returns a string representation of this <code>JViewport</code>.
		''' This method
		''' is intended to be used only for debugging purposes, and the
		''' content and format of the returned string may vary between
		''' implementations. The returned string may be empty but may not
		''' be <code>null</code>.
		''' </summary>
		''' <returns>  a string representation of this <code>JViewport</code> </returns>
		Protected Friend Overrides Function paramString() As String
			Dim isViewSizeSetString As String = (If(isViewSizeSet, "true", "false"))
			Dim lastPaintPositionString As String = (If(lastPaintPosition IsNot Nothing, lastPaintPosition.ToString(), ""))
			Dim scrollUnderwayString As String = (If(scrollUnderway, "true", "false"))

			Return MyBase.paramString() & ",isViewSizeSet=" & isViewSizeSetString & ",lastPaintPosition=" & lastPaintPositionString & ",scrollUnderway=" & scrollUnderwayString
		End Function

		'
		' Following is used when doBlit is true.
		'

		''' <summary>
		''' Notifies listeners of a property change. This is subclassed to update
		''' the <code>windowBlit</code> property.
		''' (The <code>putClientProperty</code> property is final).
		''' </summary>
		''' <param name="propertyName"> a string containing the property name </param>
		''' <param name="oldValue"> the old value of the property </param>
		''' <param name="newValue">  the new value of the property </param>
		Protected Friend Overridable Sub firePropertyChange(ByVal propertyName As String, ByVal oldValue As Object, ByVal newValue As Object)
			MyBase.firePropertyChange(propertyName, oldValue, newValue)
			If propertyName.Equals(EnableWindowBlit) Then
				If newValue IsNot Nothing Then
					scrollMode = BLIT_SCROLL_MODE
				Else
					scrollMode = SIMPLE_SCROLL_MODE
				End If
			End If
		End Sub

		''' <summary>
		''' Returns true if the component needs to be completely repainted after
		''' a blit and a paint is received.
		''' </summary>
		Private Function needsRepaintAfterBlit() As Boolean
			' Find the first heavy weight ancestor. isObscured and
			' canDetermineObscurity are only appropriate for heavy weights.
			Dim heavyParent As Component = parent

			Do While heavyParent IsNot Nothing AndAlso heavyParent.lightweight
				heavyParent = heavyParent.parent
			Loop

			If heavyParent IsNot Nothing Then
				Dim peer As java.awt.peer.ComponentPeer = heavyParent.peer

				If peer IsNot Nothing AndAlso peer.canDetermineObscurity() AndAlso (Not peer.obscured) Then Return False
			End If
			Return True
		End Function

		Private Function createRepaintTimer() As Timer
'JAVA TO VB CONVERTER TODO TASK: Anonymous inner classes are not converted to VB if the base type is not defined in the code being converted:
'			Timer timer = New Timer(300, New ActionListener()
	'		{
	'			public void actionPerformed(ActionEvent ae)
	'			{
	'				' waitingForRepaint will be false if a paint came down
	'				' with the complete clip rect, in which case we don't
	'				' have to cause a repaint.
	'				if (waitingForRepaint)
	'				{
	'					repaint();
	'				}
	'			}
	'		});
			timer.repeats = False
			Return timer
		End Function

		''' <summary>
		''' If the repaint manager has a dirty region for the view, the view is
		''' asked to paint.
		''' </summary>
		''' <param name="g">  the <code>Graphics</code> context within which to paint </param>
		Private Sub flushViewDirtyRegion(ByVal g As Graphics, ByVal dirty As Rectangle)
			Dim ___view As JComponent = CType(view, JComponent)
			If dirty IsNot Nothing AndAlso dirty.width > 0 AndAlso dirty.height > 0 Then
				dirty.x += ___view.x
				dirty.y += ___view.y
				Dim clip As Rectangle = g.clipBounds
				If clip Is Nothing Then g.cliplip(0, 0, width, height)
				g.clipRect(dirty.x, dirty.y, dirty.width, dirty.height)
				clip = g.clipBounds
				' Only paint the dirty region if it is visible.
				If clip.width > 0 AndAlso clip.height > 0 Then paintView(g)
			End If
		End Sub

		''' <summary>
		''' Used when blitting.
		''' </summary>
		''' <param name="g">  the <code>Graphics</code> context within which to paint </param>
		''' <returns> true if blitting succeeded; otherwise false </returns>
		Private Function windowBlitPaint(ByVal g As Graphics) As Boolean
			Dim ___width As Integer = width
			Dim ___height As Integer = height

			If (___width = 0) OrElse (___height = 0) Then Return False

			Dim retValue As Boolean
			Dim rm As RepaintManager = RepaintManager.currentManager(Me)
			Dim ___view As JComponent = CType(view, JComponent)

			If lastPaintPosition Is Nothing OrElse lastPaintPosition.Equals(viewLocation) Then
				paintView(g)
				retValue = False
			Else
				' The image was scrolled. Manipulate the backing store and flush
				' it to g.
				Dim blitFrom As New Point
				Dim blitTo As New Point
				Dim blitSize As New Dimension
				Dim blitPaint As New Rectangle

				Dim newLocation As Point = viewLocation
				Dim dx As Integer = newLocation.x - lastPaintPosition.x
				Dim dy As Integer = newLocation.y - lastPaintPosition.y
				Dim canBlit As Boolean = computeBlit(dx, dy, blitFrom, blitTo, blitSize, blitPaint)
				If Not canBlit Then
					paintView(g)
					retValue = False
				Else
					' Prepare the rest of the view; the part that has just been
					' exposed.
					Dim r As Rectangle = ___view.bounds.intersection(blitPaint)
					r.x -= ___view.x
					r.y -= ___view.y

					blitDoubleBuffered(___view, g, r.x, r.y, r.width, r.height, blitFrom.x, blitFrom.y, blitTo.x, blitTo.y, blitSize.width, blitSize.height)
					retValue = True
				End If
			End If
			lastPaintPosition = viewLocation
			Return retValue
		End Function

		'
		' NOTE: the code below uses paintForceDoubleBuffered for historical
		' reasons.  If we're going to allow a blit we've already accounted for
		' everything that paintImmediately and _paintImmediately does, for that
		' reason we call into paintForceDoubleBuffered to diregard whether or
		' not setDoubleBuffered(true) was invoked on the view.
		'

		Private Sub blitDoubleBuffered(ByVal view As JComponent, ByVal g As Graphics, ByVal clipX As Integer, ByVal clipY As Integer, ByVal clipW As Integer, ByVal clipH As Integer, ByVal blitFromX As Integer, ByVal blitFromY As Integer, ByVal blitToX As Integer, ByVal blitToY As Integer, ByVal blitW As Integer, ByVal blitH As Integer)
			' NOTE:
			'   blitFrom/blitTo are in JViewport coordinates system
			'     not the views coordinate space.
			'   clip* are in the views coordinate space.
			Dim rm As RepaintManager = RepaintManager.currentManager(Me)
			Dim bdx As Integer = blitToX - blitFromX
			Dim bdy As Integer = blitToY - blitFromY

			Dim oldComposite As Composite = Nothing
			' Shift the scrolled region
			If TypeOf g Is Graphics2D Then
				Dim g2d As Graphics2D = CType(g, Graphics2D)
				oldComposite = g2d.composite
				g2d.composite = AlphaComposite.Src
			End If
			rm.copyArea(Me, g, blitFromX, blitFromY, blitW, blitH, bdx, bdy, False)
			If oldComposite IsNot Nothing Then CType(g, Graphics2D).composite = oldComposite
			' Paint the newly exposed region.
			Dim ___x As Integer = view.x
			Dim ___y As Integer = view.y
			g.translate(___x, ___y)
			g.cliplip(clipX, clipY, clipW, clipH)
			view.paintForceDoubleBuffered(g)
			g.translate(-___x, -___y)
		End Sub

		''' <summary>
		''' Called to paint the view, usually when <code>blitPaint</code>
		''' can not blit.
		''' </summary>
		''' <param name="g"> the <code>Graphics</code> context within which to paint </param>
		Private Sub paintView(ByVal g As Graphics)
			Dim clip As Rectangle = g.clipBounds
			Dim ___view As JComponent = CType(view, JComponent)

			If ___view.width >= width Then
				' Graphics is relative to JViewport, need to map to view's
				' coordinates space.
				Dim ___x As Integer = ___view.x
				Dim ___y As Integer = ___view.y
				g.translate(___x, ___y)
				g.cliplip(clip.x - ___x, clip.y - ___y, clip.width, clip.height)
				___view.paintForceDoubleBuffered(g)
				g.translate(-___x, -___y)
				g.cliplip(clip.x, clip.y, clip.width, clip.height)
			Else
				' To avoid any problems that may result from the viewport being
				' bigger than the view we start painting from the viewport.
				Try
					inBlitPaint = True
					paintForceDoubleBuffered(g)
				Finally
					inBlitPaint = False
				End Try
			End If
		End Sub

		''' <summary>
		''' Returns true if the viewport is not obscured by one of its ancestors,
		''' or its ancestors children and if the viewport is showing. Blitting
		''' when the view isn't showing will work,
		''' or rather <code>copyArea</code> will work,
		''' but will not produce the expected behavior.
		''' </summary>
		Private Function canUseWindowBlitter() As Boolean
			If (Not showing) OrElse (Not(TypeOf parent Is JComponent) AndAlso Not(TypeOf view Is JComponent)) Then Return False
			If painting Then Return False

			Dim dirtyRegion As Rectangle = RepaintManager.currentManager(Me).getDirtyRegion(CType(parent, JComponent))

			If dirtyRegion IsNot Nothing AndAlso dirtyRegion.width > 0 AndAlso dirtyRegion.height > 0 Then Return False

			Dim clip As New Rectangle(0,0,width,height)
			Dim oldClip As New Rectangle
			Dim tmp2 As Rectangle = Nothing
			Dim parent As Container
			Dim lastParent As Component = Nothing
			Dim ___x, ___y, w, h As Integer

			parent = Me
			Do While parent IsNot Nothing AndAlso isLightweightComponent(parent)
				___x = parent.x
				___y = parent.y
				w = parent.width
				h = parent.height

				oldClip.bounds = clip
				SwingUtilities.computeIntersection(0, 0, w, h, clip)
				If Not clip.Equals(oldClip) Then Return False

				If lastParent IsNot Nothing AndAlso TypeOf parent Is JComponent AndAlso (Not CType(parent, JComponent).optimizedDrawingEnabled) Then
					Dim comps As Component() = parent.components
					Dim index As Integer = 0

					For i As Integer = comps.Length - 1 To 0 Step -1
						If comps(i) Is lastParent Then
							index = i - 1
							Exit For
						End If
					Next i

					Do While index >= 0
						tmp2 = comps(index).getBounds(tmp2)

						If tmp2.intersects(clip) Then Return False
						index -= 1
					Loop
				End If
				clip.x += ___x
				clip.y += ___y
				lastParent = parent
				parent = parent.parent
			Loop
			If parent Is Nothing Then Return False
			Return True
		End Function


	'///////////////
	' Accessibility support
	'//////////////

		''' <summary>
		''' Gets the AccessibleContext associated with this JViewport.
		''' For viewports, the AccessibleContext takes the form of an
		''' AccessibleJViewport.
		''' A new AccessibleJViewport instance is created if necessary.
		''' </summary>
		''' <returns> an AccessibleJViewport that serves as the
		'''         AccessibleContext of this JViewport </returns>
		Public Overridable Property accessibleContext As AccessibleContext Implements Accessible.getAccessibleContext
			Get
				If accessibleContext Is Nothing Then accessibleContext = New AccessibleJViewport(Me)
				Return accessibleContext
			End Get
		End Property

		''' <summary>
		''' This class implements accessibility support for the
		''' <code>JViewport</code> class.  It provides an implementation of the
		''' Java Accessibility API appropriate to viewport user-interface elements.
		''' <p>
		''' <strong>Warning:</strong>
		''' Serialized objects of this class will not be compatible with
		''' future Swing releases. The current serialization support is
		''' appropriate for short term storage or RMI between applications running
		''' the same version of Swing.  As of 1.4, support for long term storage
		''' of all JavaBeans&trade;
		''' has been added to the <code>java.beans</code> package.
		''' Please see <seealso cref="java.beans.XMLEncoder"/>.
		''' </summary>
		Protected Friend Class AccessibleJViewport
			Inherits AccessibleJComponent

			Private ReadOnly outerInstance As JViewport

			Public Sub New(ByVal outerInstance As JViewport)
				Me.outerInstance = outerInstance
			End Sub

			''' <summary>
			''' Get the role of this object.
			''' </summary>
			''' <returns> an instance of AccessibleRole describing the role of
			''' the object </returns>
			Public Overridable Property accessibleRole As AccessibleRole
				Get
					Return AccessibleRole.VIEWPORT
				End Get
			End Property
		End Class ' inner class AccessibleJViewport
	End Class

End Namespace